"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/slotGenerator.ts":
/*!**********************************!*\
  !*** ./src/lib/slotGenerator.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterBookedSlots: () => (/* binding */ filterBookedSlots),\n/* harmony export */   filterPastSlots: () => (/* binding */ filterPastSlots),\n/* harmony export */   generateSlotsForDate: () => (/* binding */ generateSlotsForDate),\n/* harmony export */   generateSlotsFromOperatingHours: () => (/* binding */ generateSlotsFromOperatingHours)\n/* harmony export */ });\n/**\n * Generate time slots based on operating hours and booking duration\n */ function generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday) {\n    const dayHours = operatingHours.find((h)=>h.weekday === weekday);\n    if (!dayHours || !dayHours.isActive || dayHours.timeIntervals.length === 0) {\n        return [];\n    }\n    const slots = [];\n    const durationMinutes = globalSettings.bookingDurationMinutes;\n    for (const interval of dayHours.timeIntervals){\n        const [openHour, openMinute] = interval.openTime.split(':').map(Number);\n        const [closeHour, closeMinute] = interval.closeTime.split(':').map(Number);\n        const openMinutes = openHour * 60 + openMinute;\n        const closeMinutes = closeHour * 60 + closeMinute;\n        // Generate slots within this interval\n        let currentMinutes = openMinutes;\n        while(currentMinutes + durationMinutes <= closeMinutes){\n            const startHour = Math.floor(currentMinutes / 60);\n            const startMinute = currentMinutes % 60;\n            const endMinutes = currentMinutes + durationMinutes;\n            const endHour = Math.floor(endMinutes / 60);\n            const endMinute = endMinutes % 60;\n            const startTime = \"\".concat(startHour.toString().padStart(2, '0'), \":\").concat(startMinute.toString().padStart(2, '0'));\n            const endTime = \"\".concat(endHour.toString().padStart(2, '0'), \":\").concat(endMinute.toString().padStart(2, '0'));\n            slots.push(\"\".concat(startTime, \" - \").concat(endTime));\n            currentMinutes += durationMinutes;\n        }\n    }\n    return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n            numeric: true\n        }));\n}\n/**\n * Generate slots for a specific date using operating hours\n */ async function generateSlotsForDate(date, service) {\n    try {\n        // console.log('üîç Generating slots for date:', date, 'service:', service);\n        // First try to get operating hours and global settings\n        const [hoursRes, settingsRes] = await Promise.all([\n            fetch('/api/operating-hours').catch(()=>({\n                    json: ()=>[]\n                })),\n            fetch('/api/global-settings').catch(()=>({\n                    json: ()=>null\n                }))\n        ]);\n        const operatingHours = await hoursRes.json();\n        const globalSettings = await settingsRes.json();\n        // console.log('üìä Operating hours:', operatingHours);\n        // console.log('‚öôÔ∏è Global settings:', globalSettings);\n        // If we have operating hours configured, use the new system\n        if (operatingHours.length > 0 && globalSettings && operatingHours.some((h)=>h.isActive && h.timeIntervals.length > 0)) {\n            // console.log('‚úÖ Using new operating hours system');\n            const weekday = new Date(date).getDay();\n            const baseSlots = generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday);\n            // console.log('üéØ Generated base slots:', baseSlots);\n            // Check for date-specific overrides\n            try {\n                // console.log('üîç Checking for date overrides for date:', date);\n                const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                const overrides = await overridesRes.json();\n                // console.log('üìã Date overrides found:', overrides);\n                if (Array.isArray(overrides) && overrides.length > 0) {\n                    const availableOverrides = overrides.filter((o)=>o.available && (!service || !o.service || o.service === service)).map((o)=>o.time);\n                    // console.log('‚úÖ Available overrides:', availableOverrides);\n                    if (availableOverrides.length > 0) {\n                        return availableOverrides.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    } else {\n                    // console.log('‚ö†Ô∏è No available overrides found, using base slots instead');\n                    }\n                } else {\n                // console.log('üìÖ No date overrides found, using base slots');\n                }\n            } catch (error) {\n                console.warn('Could not fetch date overrides:', error);\n            }\n            // Check for blocked intervals\n            try {\n                // console.log('üîç Checking for blocked intervals for date:', date);\n                const blockedRes = await fetch(\"/api/blocked-intervals?date=\".concat(date));\n                const blockedIntervals = await blockedRes.json();\n                // console.log('üö´ Blocked intervals found:', blockedIntervals);\n                if (Array.isArray(blockedIntervals) && blockedIntervals.length > 0) {\n                    // Filter out slots that overlap with blocked intervals\n                    const filteredSlots = baseSlots.filter((slot)=>{\n                        const [slotStart, slotEnd] = slot.split(' - ');\n                        const slotStartMinutes = timeToMinutes(slotStart);\n                        const slotEndMinutes = timeToMinutes(slotEnd);\n                        const hasOverlap = blockedIntervals.some((interval)=>{\n                            const intervalStartMinutes = timeToMinutes(interval.startTime);\n                            const intervalEndMinutes = timeToMinutes(interval.endTime);\n                            const overlaps = slotStartMinutes < intervalEndMinutes && slotEndMinutes > intervalStartMinutes;\n                            if (overlaps) {\n                            // console.log(`üö´ Slot ${slot} overlaps with blocked interval ${interval.startTime}-${interval.endTime} (${interval.reason || 'No reason'})`);\n                            }\n                            return overlaps;\n                        });\n                        return !hasOverlap;\n                    });\n                    // console.log('‚úÖ Slots after blocked intervals filter:', filteredSlots);\n                    return filteredSlots;\n                } else {\n                // console.log('üìÖ No blocked intervals found, using base slots');\n                }\n            } catch (error) {\n                console.warn('Could not fetch blocked intervals:', error);\n            }\n            // console.log('üéØ Returning baseSlots from new system:', baseSlots);\n            return baseSlots;\n        }\n        // Fallback to old system - use global timeslots\n        // console.log('üîÑ Falling back to old global timeslots system');\n        try {\n            const globalSlotsRes = await fetch('/api/global-timeslots');\n            const globalSlots = await globalSlotsRes.json();\n            // console.log('üìÖ Global slots from old system:', globalSlots);\n            if (Array.isArray(globalSlots) && globalSlots.length > 0) {\n                const weekday = new Date(date).getDay();\n                const slots = globalSlots.filter((s)=>Number(s.weekday) === Number(weekday)).map((s)=>s.time);\n                // Check for date-specific overrides\n                try {\n                    const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                    const overrides = await overridesRes.json();\n                    if (Array.isArray(overrides) && overrides.some((o)=>o.available)) {\n                        const available = overrides.filter((o)=>o.available).map((o)=>o.time);\n                        return available.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    }\n                } catch (error) {\n                    console.warn('Could not fetch date overrides:', error);\n                }\n                return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n                        numeric: true\n                    }));\n            }\n        } catch (error) {\n            console.warn('Could not fetch global timeslots:', error);\n        }\n        // Final fallback - return empty array\n        // console.log('‚ùå No slots found for date:', date);\n        return [];\n    } catch (error) {\n        console.error('‚ùå Error generating slots for date:', error);\n        return [];\n    }\n}\n/**\n * Filter out past slots if the date is today\n */ function filterPastSlots(slots, date) {\n    const today = new Date();\n    const selectedDate = new Date(date);\n    // console.log('üïê Filtering past slots. Date:', date, 'Today:', today.toISOString().split('T')[0]);\n    // If not today, return all slots\n    if (today.getFullYear() !== selectedDate.getFullYear() || today.getMonth() !== selectedDate.getMonth() || today.getDate() !== selectedDate.getDate()) {\n        // console.log('üìÖ Not today, returning all slots:', slots);\n        return slots;\n    }\n    // Filter out past slots\n    const nowMinutes = today.getHours() * 60 + today.getMinutes();\n    // console.log('‚è∞ Current time in minutes:', nowMinutes);\n    const filtered = slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        const [hour, minute] = startTime.split(':').map(Number);\n        const slotMinutes = hour * 60 + minute;\n        const isPast = slotMinutes <= nowMinutes;\n        // console.log(`‚è∞ Slot ${slot} (${slotMinutes} min) - Past: ${isPast}`);\n        return !isPast;\n    });\n    // console.log('‚úÖ Past slots filtered:', filtered);\n    return filtered;\n}\n/**\n * Remove already booked slots (check for time overlap)\n */ function filterBookedSlots(slots, bookedSlots) {\n    // console.log('üîç Filtering booked slots. Available slots:', slots);\n    // console.log('üìÖ Booked slots:', bookedSlots);\n    const filtered = slots.filter((slot)=>{\n        const [slotStart, slotEnd] = slot.split(' - ');\n        const isBooked = bookedSlots.some((bookedTime)=>{\n            // Check if the booked time overlaps with this slot\n            // A booked time at 19:00 should block slots that start at 19:00 or later\n            // but also slots that end at 19:00 or later (like 18:15-19:00)\n            // Convert times to minutes for easier comparison\n            const slotStartMinutes = timeToMinutes(slotStart);\n            const slotEndMinutes = timeToMinutes(slotEnd);\n            const bookedMinutes = timeToMinutes(bookedTime);\n            // Check for overlap: slot overlaps if it starts before booked time ends\n            // and ends after booked time starts\n            // Since we don't know the duration of the booked slot, we assume it's 45 minutes\n            const bookedEndMinutes = bookedMinutes + 45; // Assume 45 min duration\n            const hasOverlap = slotStartMinutes < bookedEndMinutes && slotEndMinutes > bookedMinutes;\n            // console.log(`‚è∞ Slot ${slot} (${slotStartMinutes}-${slotEndMinutes} min) vs Booked ${bookedTime} (${bookedMinutes}-${bookedEndMinutes} min) - Overlap: ${hasOverlap}`);\n            return hasOverlap;\n        });\n        // console.log(`‚è∞ Slot ${slot} - Booked: ${isBooked}`);\n        return !isBooked;\n    });\n    // console.log('‚úÖ Filtered slots:', filtered);\n    return filtered;\n}\n/**\n * Convert time string (HH:MM) to minutes since midnight\n */ function timeToMinutes(time) {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZ0JBOztDQUVDLEdBQ00sU0FBU0EsZ0NBQ2RDLGNBQWdDLEVBQ2hDQyxjQUE4QixFQUM5QkMsT0FBZTtJQUVmLE1BQU1DLFdBQVdILGVBQWVJLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsT0FBTyxLQUFLQTtJQUV4RCxJQUFJLENBQUNDLFlBQVksQ0FBQ0EsU0FBU0csUUFBUSxJQUFJSCxTQUFTSSxhQUFhLENBQUNDLE1BQU0sS0FBSyxHQUFHO1FBQzFFLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUMsUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxrQkFBa0JULGVBQWVVLHNCQUFzQjtJQUU3RCxLQUFLLE1BQU1DLFlBQVlULFNBQVNJLGFBQWEsQ0FBRTtRQUM3QyxNQUFNLENBQUNNLFVBQVVDLFdBQVcsR0FBR0YsU0FBU0csUUFBUSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUNoRSxNQUFNLENBQUNDLFdBQVdDLFlBQVksR0FBR1IsU0FBU1MsU0FBUyxDQUFDTCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUVuRSxNQUFNSSxjQUFjVCxXQUFXLEtBQUtDO1FBQ3BDLE1BQU1TLGVBQWVKLFlBQVksS0FBS0M7UUFFdEMsc0NBQXNDO1FBQ3RDLElBQUlJLGlCQUFpQkY7UUFFckIsTUFBT0UsaUJBQWlCZCxtQkFBbUJhLGFBQWM7WUFDdkQsTUFBTUUsWUFBWUMsS0FBS0MsS0FBSyxDQUFDSCxpQkFBaUI7WUFDOUMsTUFBTUksY0FBY0osaUJBQWlCO1lBQ3JDLE1BQU1LLGFBQWFMLGlCQUFpQmQ7WUFDcEMsTUFBTW9CLFVBQVVKLEtBQUtDLEtBQUssQ0FBQ0UsYUFBYTtZQUN4QyxNQUFNRSxZQUFZRixhQUFhO1lBRS9CLE1BQU1HLFlBQVksR0FBNENKLE9BQXpDSCxVQUFVUSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxH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QkFBaUIwQjtZQUUzRSx5S0FBeUs7WUFFekssT0FBT3pCO1FBQ1Q7UUFFQSx1REFBdUQ7UUFDdkQsT0FBTyxDQUFDdUI7SUFDVjtJQUVBLDhDQUE4QztJQUM5QyxPQUFPUDtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTbEIsY0FBY1gsSUFBWTtJQUNqQyxNQUFNLENBQUN3QyxPQUFPQyxRQUFRLEdBQUd6QyxLQUFLaEQsS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQ0M7SUFDN0MsT0FBT3NGLFFBQVEsS0FBS0M7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rb25zdGFudGlub3NsZXBpZGFzL0Rlc2t0b3AvYXZnb3VzdGUvYWN1cHVuY3R1cmUtYm9va2luZy9zcmMvbGliL3Nsb3RHZW5lcmF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFRpbWVJbnRlcnZhbCB7XG4gIGlkOiBzdHJpbmc7XG4gIG9wZW5UaW1lOiBzdHJpbmc7XG4gIGNsb3NlVGltZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT3BlcmF0aW5nSG91cnMge1xuICB3ZWVrZGF5OiBudW1iZXI7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICB0aW1lSW50ZXJ2YWxzOiBUaW1lSW50ZXJ2YWxbXTtcbn1cblxuaW50ZXJmYWNlIEdsb2JhbFNldHRpbmdzIHtcbiAgYm9va2luZ0R1cmF0aW9uTWludXRlczogbnVtYmVyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRpbWUgc2xvdHMgYmFzZWQgb24gb3BlcmF0aW5nIGhvdXJzIGFuZCBib29raW5nIGR1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNsb3RzRnJvbU9wZXJhdGluZ0hvdXJzKFxuICBvcGVyYXRpbmdIb3VyczogT3BlcmF0aW5nSG91cnNbXSxcbiAgZ2xvYmFsU2V0dGluZ3M6IEdsb2JhbFNldHRpbmdzLFxuICB3ZWVrZGF5OiBudW1iZXJcbik6IHN0cmluZ1tdIHtcbiAgY29uc3QgZGF5SG91cnMgPSBvcGVyYXRpbmdIb3Vycy5maW5kKGggPT4gaC53ZWVrZGF5ID09PSB3ZWVrZGF5KTtcbiAgXG4gIGlmICghZGF5SG91cnMgfHwgIWRheUhvdXJzLmlzQWN0aXZlIHx8IGRheUhvdXJzLnRpbWVJbnRlcnZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgc2xvdHM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGR1cmF0aW9uTWludXRlcyA9IGdsb2JhbFNldHRpbmdzLmJvb2tpbmdEdXJhdGlvbk1pbnV0ZXM7XG5cbiAgZm9yIChjb25zdCBpbnRlcnZhbCBvZiBkYXlIb3Vycy50aW1lSW50ZXJ2YWxzKSB7XG4gICAgY29uc3QgW29wZW5Ib3VyLCBvcGVuTWludXRlXSA9IGludGVydmFsLm9wZW5UaW1lLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG4gICAgY29uc3QgW2Nsb3NlSG91ciwgY2xvc2VNaW51dGVdID0gaW50ZXJ2YWwuY2xvc2VUaW1lLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG4gICAgXG4gICAgY29uc3Qgb3Blbk1pbnV0ZXMgPSBvcGVuSG91ciAqIDYwICsgb3Blbk1pbnV0ZTtcbiAgICBjb25zdCBjbG9zZU1pbnV0ZXMgPSBjbG9zZUhvdXIgKiA2MCArIGNsb3NlTWludXRlO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHNsb3RzIHdpdGhpbiB0aGlzIGludGVydmFsXG4gICAgbGV0IGN1cnJlbnRNaW51dGVzID0gb3Blbk1pbnV0ZXM7XG4gICAgXG4gICAgd2hpbGUgKGN1cnJlbnRNaW51dGVzICsgZHVyYXRpb25NaW51dGVzIDw9IGNsb3NlTWludXRlcykge1xuICAgICAgY29uc3Qgc3RhcnRIb3VyID0gTWF0aC5mbG9vcihjdXJyZW50TWludXRlcyAvIDYwKTtcbiAgICAgIGNvbnN0IHN0YXJ0TWludXRlID0gY3VycmVudE1pbnV0ZXMgJSA2MDtcbiAgICAgIGNvbnN0IGVuZE1pbnV0ZXMgPSBjdXJyZW50TWludXRlcyArIGR1cmF0aW9uTWludXRlcztcbiAgICAgIGNvbnN0IGVuZEhvdXIgPSBNYXRoLmZsb29yKGVuZE1pbnV0ZXMgLyA2MCk7XG4gICAgICBjb25zdCBlbmRNaW51dGUgPSBlbmRNaW51dGVzICUgNjA7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGAke3N0YXJ0SG91ci50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7c3RhcnRNaW51dGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgICBjb25zdCBlbmRUaW1lID0gYCR7ZW5kSG91ci50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7ZW5kTWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICAgICAgXG4gICAgICBzbG90cy5wdXNoKGAke3N0YXJ0VGltZX0gLSAke2VuZFRpbWV9YCk7XG4gICAgICBcbiAgICAgIGN1cnJlbnRNaW51dGVzICs9IGR1cmF0aW9uTWludXRlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2xvdHMuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIsICdlbicsIHsgbnVtZXJpYzogdHJ1ZSB9KSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgc2xvdHMgZm9yIGEgc3BlY2lmaWMgZGF0ZSB1c2luZyBvcGVyYXRpbmcgaG91cnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlU2xvdHNGb3JEYXRlKFxuICBkYXRlOiBzdHJpbmcsXG4gIHNlcnZpY2U/OiBzdHJpbmdcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBjb25zb2xlLmxvZygn8J+UjSBHZW5lcmF0aW5nIHNsb3RzIGZvciBkYXRlOicsIGRhdGUsICdzZXJ2aWNlOicsIHNlcnZpY2UpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgb3BlcmF0aW5nIGhvdXJzIGFuZCBnbG9iYWwgc2V0dGluZ3NcbiAgICBjb25zdCBbaG91cnNSZXMsIHNldHRpbmdzUmVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZldGNoKCcvYXBpL29wZXJhdGluZy1ob3VycycpLmNhdGNoKCgpID0+ICh7IGpzb246ICgpID0+IFtdIH0pKSxcbiAgICAgIGZldGNoKCcvYXBpL2dsb2JhbC1zZXR0aW5ncycpLmNhdGNoKCgpID0+ICh7IGpzb246ICgpID0+IG51bGwgfSkpXG4gICAgXSk7XG4gICAgXG4gICAgY29uc3Qgb3BlcmF0aW5nSG91cnM6IE9wZXJhdGluZ0hvdXJzW10gPSBhd2FpdCBob3Vyc1Jlcy5qc29uKCk7XG4gICAgY29uc3QgZ2xvYmFsU2V0dGluZ3M6IEdsb2JhbFNldHRpbmdzID0gYXdhaXQgc2V0dGluZ3NSZXMuanNvbigpO1xuICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKCfwn5OKIE9wZXJhdGluZyBob3VyczonLCBvcGVyYXRpbmdIb3Vycyk7XG4gICAgLy8gY29uc29sZS5sb2coJ+Kame+4jyBHbG9iYWwgc2V0dGluZ3M6JywgZ2xvYmFsU2V0dGluZ3MpO1xuICAgIFxuICAgIC8vIElmIHdlIGhhdmUgb3BlcmF0aW5nIGhvdXJzIGNvbmZpZ3VyZWQsIHVzZSB0aGUgbmV3IHN5c3RlbVxuICAgIGlmIChvcGVyYXRpbmdIb3Vycy5sZW5ndGggPiAwICYmIGdsb2JhbFNldHRpbmdzICYmIG9wZXJhdGluZ0hvdXJzLnNvbWUoaCA9PiBoLmlzQWN0aXZlICYmIGgudGltZUludGVydmFscy5sZW5ndGggPiAwKSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ+KchSBVc2luZyBuZXcgb3BlcmF0aW5nIGhvdXJzIHN5c3RlbScpO1xuICAgICAgY29uc3Qgd2Vla2RheSA9IG5ldyBEYXRlKGRhdGUpLmdldERheSgpO1xuICAgICAgY29uc3QgYmFzZVNsb3RzID0gZ2VuZXJhdGVTbG90c0Zyb21PcGVyYXRpbmdIb3VycyhvcGVyYXRpbmdIb3VycywgZ2xvYmFsU2V0dGluZ3MsIHdlZWtkYXkpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ/Cfjq8gR2VuZXJhdGVkIGJhc2Ugc2xvdHM6JywgYmFzZVNsb3RzKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGRhdGUtc3BlY2lmaWMgb3ZlcnJpZGVzXG4gICAgICB0cnkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+UjSBDaGVja2luZyBmb3IgZGF0ZSBvdmVycmlkZXMgZm9yIGRhdGU6JywgZGF0ZSk7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlc1JlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGUtb3ZlcnJpZGVzP2RhdGU9JHtkYXRlfWApO1xuICAgICAgICBjb25zdCBvdmVycmlkZXMgPSBhd2FpdCBvdmVycmlkZXNSZXMuanNvbigpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+TiyBEYXRlIG92ZXJyaWRlcyBmb3VuZDonLCBvdmVycmlkZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3ZlcnJpZGVzKSAmJiBvdmVycmlkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZU92ZXJyaWRlcyA9IG92ZXJyaWRlc1xuICAgICAgICAgICAgLmZpbHRlcigobzogeyBhdmFpbGFibGU6IGJvb2xlYW47IHNlcnZpY2U/OiBzdHJpbmcgfSkgPT4gXG4gICAgICAgICAgICAgIG8uYXZhaWxhYmxlICYmICghc2VydmljZSB8fCAhby5zZXJ2aWNlIHx8IG8uc2VydmljZSA9PT0gc2VydmljZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5tYXAoKG86IHsgdGltZTogc3RyaW5nIH0pID0+IG8udGltZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ+KchSBBdmFpbGFibGUgb3ZlcnJpZGVzOicsIGF2YWlsYWJsZU92ZXJyaWRlcyk7XG4gICAgICAgICAgaWYgKGF2YWlsYWJsZU92ZXJyaWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlT3ZlcnJpZGVzLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBcbiAgICAgICAgICAgICAgYS5sb2NhbGVDb21wYXJlKGIsICdlbicsIHsgbnVtZXJpYzogdHJ1ZSB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ+KaoO+4jyBObyBhdmFpbGFibGUgb3ZlcnJpZGVzIGZvdW5kLCB1c2luZyBiYXNlIHNsb3RzIGluc3RlYWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ/Cfk4UgTm8gZGF0ZSBvdmVycmlkZXMgZm91bmQsIHVzaW5nIGJhc2Ugc2xvdHMnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggZGF0ZSBvdmVycmlkZXM6JywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgYmxvY2tlZCBpbnRlcnZhbHNcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfwn5SNIENoZWNraW5nIGZvciBibG9ja2VkIGludGVydmFscyBmb3IgZGF0ZTonLCBkYXRlKTtcbiAgICAgICAgY29uc3QgYmxvY2tlZFJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2Jsb2NrZWQtaW50ZXJ2YWxzP2RhdGU9JHtkYXRlfWApO1xuICAgICAgICBjb25zdCBibG9ja2VkSW50ZXJ2YWxzID0gYXdhaXQgYmxvY2tlZFJlcy5qc29uKCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCfwn5qrIEJsb2NrZWQgaW50ZXJ2YWxzIGZvdW5kOicsIGJsb2NrZWRJbnRlcnZhbHMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvY2tlZEludGVydmFscykgJiYgYmxvY2tlZEludGVydmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBzbG90cyB0aGF0IG92ZXJsYXAgd2l0aCBibG9ja2VkIGludGVydmFsc1xuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkU2xvdHMgPSBiYXNlU2xvdHMuZmlsdGVyKHNsb3QgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3Nsb3RTdGFydCwgc2xvdEVuZF0gPSBzbG90LnNwbGl0KCcgLSAnKTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RTdGFydE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKHNsb3RTdGFydCk7XG4gICAgICAgICAgICBjb25zdCBzbG90RW5kTWludXRlcyA9IHRpbWVUb01pbnV0ZXMoc2xvdEVuZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGhhc092ZXJsYXAgPSBibG9ja2VkSW50ZXJ2YWxzLnNvbWUoKGludGVydmFsOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWxTdGFydE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKGludGVydmFsLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGludGVydmFsRW5kTWludXRlcyA9IHRpbWVUb01pbnV0ZXMoaW50ZXJ2YWwuZW5kVGltZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcyA9IHNsb3RTdGFydE1pbnV0ZXMgPCBpbnRlcnZhbEVuZE1pbnV0ZXMgJiYgc2xvdEVuZE1pbnV0ZXMgPiBpbnRlcnZhbFN0YXJ0TWludXRlcztcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGDwn5qrIFNsb3QgJHtzbG90fSBvdmVybGFwcyB3aXRoIGJsb2NrZWQgaW50ZXJ2YWwgJHtpbnRlcnZhbC5zdGFydFRpbWV9LSR7aW50ZXJ2YWwuZW5kVGltZX0gKCR7aW50ZXJ2YWwucmVhc29uIHx8ICdObyByZWFzb24nfSlgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAhaGFzT3ZlcmxhcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygn4pyFIFNsb3RzIGFmdGVyIGJsb2NrZWQgaW50ZXJ2YWxzIGZpbHRlcjonLCBmaWx0ZXJlZFNsb3RzKTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyZWRTbG90cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+ThSBObyBibG9ja2VkIGludGVydmFscyBmb3VuZCwgdXNpbmcgYmFzZSBzbG90cycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBibG9ja2VkIGludGVydmFsczonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGNvbnNvbGUubG9nKCfwn46vIFJldHVybmluZyBiYXNlU2xvdHMgZnJvbSBuZXcgc3lzdGVtOicsIGJhc2VTbG90cyk7XG4gICAgICByZXR1cm4gYmFzZVNsb3RzO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBvbGQgc3lzdGVtIC0gdXNlIGdsb2JhbCB0aW1lc2xvdHNcbiAgICAvLyBjb25zb2xlLmxvZygn8J+UhCBGYWxsaW5nIGJhY2sgdG8gb2xkIGdsb2JhbCB0aW1lc2xvdHMgc3lzdGVtJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGdsb2JhbFNsb3RzUmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2xvYmFsLXRpbWVzbG90cycpO1xuICAgICAgY29uc3QgZ2xvYmFsU2xvdHMgPSBhd2FpdCBnbG9iYWxTbG90c1Jlcy5qc29uKCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygn8J+ThSBHbG9iYWwgc2xvdHMgZnJvbSBvbGQgc3lzdGVtOicsIGdsb2JhbFNsb3RzKTtcbiAgICAgIFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYmFsU2xvdHMpICYmIGdsb2JhbFNsb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgd2Vla2RheSA9IG5ldyBEYXRlKGRhdGUpLmdldERheSgpO1xuICAgICAgICBjb25zdCBzbG90cyA9IGdsb2JhbFNsb3RzXG4gICAgICAgICAgLmZpbHRlcigoczogeyB3ZWVrZGF5OiBudW1iZXIgfSkgPT4gTnVtYmVyKHMud2Vla2RheSkgPT09IE51bWJlcih3ZWVrZGF5KSlcbiAgICAgICAgICAubWFwKChzOiB7IHRpbWU6IHN0cmluZyB9KSA9PiBzLnRpbWUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGRhdGUtc3BlY2lmaWMgb3ZlcnJpZGVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb3ZlcnJpZGVzUmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0ZS1vdmVycmlkZXM/ZGF0ZT0ke2RhdGV9YCk7XG4gICAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gYXdhaXQgb3ZlcnJpZGVzUmVzLmpzb24oKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdmVycmlkZXMpICYmIG92ZXJyaWRlcy5zb21lKChvOiB7IGF2YWlsYWJsZTogYm9vbGVhbiB9KSA9PiBvLmF2YWlsYWJsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IG92ZXJyaWRlc1xuICAgICAgICAgICAgICAuZmlsdGVyKChvOiB7IGF2YWlsYWJsZTogYm9vbGVhbiB9KSA9PiBvLmF2YWlsYWJsZSlcbiAgICAgICAgICAgICAgLm1hcCgobzogeyB0aW1lOiBzdHJpbmcgfSkgPT4gby50aW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBkYXRlIG92ZXJyaWRlczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzbG90cy5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gYS5sb2NhbGVDb21wYXJlKGIsICdlbicsIHsgbnVtZXJpYzogdHJ1ZSB9KSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIGdsb2JhbCB0aW1lc2xvdHM6JywgZXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaW5hbCBmYWxsYmFjayAtIHJldHVybiBlbXB0eSBhcnJheVxuICAgIC8vIGNvbnNvbGUubG9nKCfinYwgTm8gc2xvdHMgZm91bmQgZm9yIGRhdGU6JywgZGF0ZSk7XG4gICAgcmV0dXJuIFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBnZW5lcmF0aW5nIHNsb3RzIGZvciBkYXRlOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IHBhc3Qgc2xvdHMgaWYgdGhlIGRhdGUgaXMgdG9kYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclBhc3RTbG90cyhzbG90czogc3RyaW5nW10sIGRhdGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBzZWxlY3RlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgXG4gIC8vIGNvbnNvbGUubG9nKCfwn5WQIEZpbHRlcmluZyBwYXN0IHNsb3RzLiBEYXRlOicsIGRhdGUsICdUb2RheTonLCB0b2RheS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0pO1xuICBcbiAgLy8gSWYgbm90IHRvZGF5LCByZXR1cm4gYWxsIHNsb3RzXG4gIGlmIChcbiAgICB0b2RheS5nZXRGdWxsWWVhcigpICE9PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKSB8fFxuICAgIHRvZGF5LmdldE1vbnRoKCkgIT09IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpIHx8XG4gICAgdG9kYXkuZ2V0RGF0ZSgpICE9PSBzZWxlY3RlZERhdGUuZ2V0RGF0ZSgpXG4gICkge1xuICAgIC8vIGNvbnNvbGUubG9nKCfwn5OFIE5vdCB0b2RheSwgcmV0dXJuaW5nIGFsbCBzbG90czonLCBzbG90cyk7XG4gICAgcmV0dXJuIHNsb3RzO1xuICB9XG4gIFxuICAvLyBGaWx0ZXIgb3V0IHBhc3Qgc2xvdHNcbiAgY29uc3Qgbm93TWludXRlcyA9IHRvZGF5LmdldEhvdXJzKCkgKiA2MCArIHRvZGF5LmdldE1pbnV0ZXMoKTtcbiAgLy8gY29uc29sZS5sb2coJ+KPsCBDdXJyZW50IHRpbWUgaW4gbWludXRlczonLCBub3dNaW51dGVzKTtcbiAgXG4gIGNvbnN0IGZpbHRlcmVkID0gc2xvdHMuZmlsdGVyKHNsb3QgPT4ge1xuICAgIGNvbnN0IFtzdGFydFRpbWVdID0gc2xvdC5zcGxpdCgnIC0gJyk7XG4gICAgY29uc3QgW2hvdXIsIG1pbnV0ZV0gPSBzdGFydFRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBjb25zdCBzbG90TWludXRlcyA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICBjb25zdCBpc1Bhc3QgPSBzbG90TWludXRlcyA8PSBub3dNaW51dGVzO1xuICAgIC8vIGNvbnNvbGUubG9nKGDij7AgU2xvdCAke3Nsb3R9ICgke3Nsb3RNaW51dGVzfSBtaW4pIC0gUGFzdDogJHtpc1Bhc3R9YCk7XG4gICAgcmV0dXJuICFpc1Bhc3Q7XG4gIH0pO1xuICBcbiAgLy8gY29uc29sZS5sb2coJ+KchSBQYXN0IHNsb3RzIGZpbHRlcmVkOicsIGZpbHRlcmVkKTtcbiAgcmV0dXJuIGZpbHRlcmVkO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbHJlYWR5IGJvb2tlZCBzbG90cyAoY2hlY2sgZm9yIHRpbWUgb3ZlcmxhcClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckJvb2tlZFNsb3RzKHNsb3RzOiBzdHJpbmdbXSwgYm9va2VkU2xvdHM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAvLyBjb25zb2xlLmxvZygn8J+UjSBGaWx0ZXJpbmcgYm9va2VkIHNsb3RzLiBBdmFpbGFibGUgc2xvdHM6Jywgc2xvdHMpO1xuICAvLyBjb25zb2xlLmxvZygn8J+ThSBCb29rZWQgc2xvdHM6JywgYm9va2VkU2xvdHMpO1xuICBcbiAgY29uc3QgZmlsdGVyZWQgPSBzbG90cy5maWx0ZXIoc2xvdCA9PiB7XG4gICAgY29uc3QgW3Nsb3RTdGFydCwgc2xvdEVuZF0gPSBzbG90LnNwbGl0KCcgLSAnKTtcbiAgICBjb25zdCBpc0Jvb2tlZCA9IGJvb2tlZFNsb3RzLnNvbWUoYm9va2VkVGltZSA9PiB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgYm9va2VkIHRpbWUgb3ZlcmxhcHMgd2l0aCB0aGlzIHNsb3RcbiAgICAgIC8vIEEgYm9va2VkIHRpbWUgYXQgMTk6MDAgc2hvdWxkIGJsb2NrIHNsb3RzIHRoYXQgc3RhcnQgYXQgMTk6MDAgb3IgbGF0ZXJcbiAgICAgIC8vIGJ1dCBhbHNvIHNsb3RzIHRoYXQgZW5kIGF0IDE5OjAwIG9yIGxhdGVyIChsaWtlIDE4OjE1LTE5OjAwKVxuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IHRpbWVzIHRvIG1pbnV0ZXMgZm9yIGVhc2llciBjb21wYXJpc29uXG4gICAgICBjb25zdCBzbG90U3RhcnRNaW51dGVzID0gdGltZVRvTWludXRlcyhzbG90U3RhcnQpO1xuICAgICAgY29uc3Qgc2xvdEVuZE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKHNsb3RFbmQpO1xuICAgICAgY29uc3QgYm9va2VkTWludXRlcyA9IHRpbWVUb01pbnV0ZXMoYm9va2VkVGltZSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBvdmVybGFwOiBzbG90IG92ZXJsYXBzIGlmIGl0IHN0YXJ0cyBiZWZvcmUgYm9va2VkIHRpbWUgZW5kc1xuICAgICAgLy8gYW5kIGVuZHMgYWZ0ZXIgYm9va2VkIHRpbWUgc3RhcnRzXG4gICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBkdXJhdGlvbiBvZiB0aGUgYm9va2VkIHNsb3QsIHdlIGFzc3VtZSBpdCdzIDQ1IG1pbnV0ZXNcbiAgICAgIGNvbnN0IGJvb2tlZEVuZE1pbnV0ZXMgPSBib29rZWRNaW51dGVzICsgNDU7IC8vIEFzc3VtZSA0NSBtaW4gZHVyYXRpb25cbiAgICAgIFxuICAgICAgY29uc3QgaGFzT3ZlcmxhcCA9IHNsb3RTdGFydE1pbnV0ZXMgPCBib29rZWRFbmRNaW51dGVzICYmIHNsb3RFbmRNaW51dGVzID4gYm9va2VkTWludXRlcztcbiAgICAgIFxuICAgICAgLy8gY29uc29sZS5sb2coYOKPsCBTbG90ICR7c2xvdH0gKCR7c2xvdFN0YXJ0TWludXRlc30tJHtzbG90RW5kTWludXRlc30gbWluKSB2cyBCb29rZWQgJHtib29rZWRUaW1lfSAoJHtib29rZWRNaW51dGVzfS0ke2Jvb2tlZEVuZE1pbnV0ZXN9IG1pbikgLSBPdmVybGFwOiAke2hhc092ZXJsYXB9YCk7XG4gICAgICBcbiAgICAgIHJldHVybiBoYXNPdmVybGFwO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKGDij7AgU2xvdCAke3Nsb3R9IC0gQm9va2VkOiAke2lzQm9va2VkfWApO1xuICAgIHJldHVybiAhaXNCb29rZWQ7XG4gIH0pO1xuICBcbiAgLy8gY29uc29sZS5sb2coJ+KchSBGaWx0ZXJlZCBzbG90czonLCBmaWx0ZXJlZCk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRpbWUgc3RyaW5nIChISDpNTSkgdG8gbWludXRlcyBzaW5jZSBtaWRuaWdodFxuICovXG5mdW5jdGlvbiB0aW1lVG9NaW51dGVzKHRpbWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IFtob3VycywgbWludXRlc10gPSB0aW1lLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG4gIHJldHVybiBob3VycyAqIDYwICsgbWludXRlcztcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZVNsb3RzRnJvbU9wZXJhdGluZ0hvdXJzIiwib3BlcmF0aW5nSG91cnMiLCJnbG9iYWxTZXR0aW5ncyIsIndlZWtkYXkiLCJkYXlIb3VycyIsImZpbmQiLCJoIiwiaXNBY3RpdmUiLCJ0aW1lSW50ZXJ2YWxzIiwibGVuZ3RoIiwic2xvdHMiLCJkdXJhdGlvbk1pbnV0ZXMiLCJib29raW5nRHVyYXRpb25NaW51dGVzIiwiaW50ZXJ2YWwiLCJvcGVuSG91ciIsIm9wZW5NaW51dGUiLCJvcGVuVGltZSIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiY2xvc2VIb3VyIiwiY2xvc2VNaW51dGUiLCJjbG9zZVRpbWUiLCJvcGVuTWludXRlcyIsImNsb3NlTWludXRlcyIsImN1cnJlbnRNaW51dGVzIiwic3RhcnRIb3VyIiwiTWF0aCIsImZsb29yIiwic3RhcnRNaW51dGUiLCJlbmRNaW51dGVzIiwiZW5kSG91ciIsImVuZE1pbnV0ZSIsInN0YXJ0VGltZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJlbmRUaW1lIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwiZ2VuZXJhdGVTbG90c0ZvckRhdGUiLCJkYXRlIiwic2VydmljZSIsImhvdXJzUmVzIiwic2V0dGluZ3NSZXMiLCJQcm9taXNlIiwiYWxsIiwiZmV0Y2giLCJjYXRjaCIsImpzb24iLCJzb21lIiwiRGF0ZSIsImdldERheSIsImJhc2VTbG90cyIsIm92ZXJyaWRlc1JlcyIsIm92ZXJyaWRlcyIsIkFycmF5IiwiaXNBcnJheSIsImF2YWlsYWJsZU92ZXJyaWRlcyIsImZpbHRlciIsIm8iLCJhdmFpbGFibGUiLCJ0aW1lIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsImJsb2NrZWRSZXMiLCJibG9ja2VkSW50ZXJ2YWxzIiwiZmlsdGVyZWRTbG90cyIsInNsb3QiLCJzbG90U3RhcnQiLCJzbG90RW5kIiwic2xvdFN0YXJ0TWludXRlcyIsInRpbWVUb01pbnV0ZXMiLCJzbG90RW5kTWludXRlcyIsImhhc092ZXJsYXAiLCJpbnRlcnZhbFN0YXJ0TWludXRlcyIsImludGVydmFsRW5kTWludXRlcyIsIm92ZXJsYXBzIiwiZ2xvYmFsU2xvdHNSZXMiLCJnbG9iYWxTbG90cyIsInMiLCJmaWx0ZXJQYXN0U2xvdHMiLCJ0b2RheSIsInNlbGVjdGVkRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwibm93TWludXRlcyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImZpbHRlcmVkIiwiaG91ciIsIm1pbnV0ZSIsInNsb3RNaW51dGVzIiwiaXNQYXN0IiwiZmlsdGVyQm9va2VkU2xvdHMiLCJib29rZWRTbG90cyIsImlzQm9va2VkIiwiYm9va2VkVGltZSIsImJvb2tlZE1pbnV0ZXMiLCJib29rZWRFbmRNaW51dGVzIiwiaG91cnMiLCJtaW51dGVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/slotGenerator.ts\n"));

/***/ })

});