"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/slotGenerator.ts":
/*!**********************************!*\
  !*** ./src/lib/slotGenerator.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterBookedSlots: () => (/* binding */ filterBookedSlots),\n/* harmony export */   filterPastSlots: () => (/* binding */ filterPastSlots),\n/* harmony export */   generateSlotsForDate: () => (/* binding */ generateSlotsForDate),\n/* harmony export */   generateSlotsFromOperatingHours: () => (/* binding */ generateSlotsFromOperatingHours)\n/* harmony export */ });\n/**\n * Generate time slots based on operating hours and booking duration\n */ function generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday) {\n    const dayHours = operatingHours.find((h)=>h.weekday === weekday);\n    if (!dayHours || !dayHours.isActive || dayHours.timeIntervals.length === 0) {\n        return [];\n    }\n    const slots = [];\n    const durationMinutes = globalSettings.bookingDurationMinutes;\n    for (const interval of dayHours.timeIntervals){\n        const [openHour, openMinute] = interval.openTime.split(':').map(Number);\n        const [closeHour, closeMinute] = interval.closeTime.split(':').map(Number);\n        const openMinutes = openHour * 60 + openMinute;\n        const closeMinutes = closeHour * 60 + closeMinute;\n        // Generate slots within this interval\n        let currentMinutes = openMinutes;\n        while(currentMinutes + durationMinutes <= closeMinutes){\n            const startHour = Math.floor(currentMinutes / 60);\n            const startMinute = currentMinutes % 60;\n            const endMinutes = currentMinutes + durationMinutes;\n            const endHour = Math.floor(endMinutes / 60);\n            const endMinute = endMinutes % 60;\n            const startTime = \"\".concat(startHour.toString().padStart(2, '0'), \":\").concat(startMinute.toString().padStart(2, '0'));\n            const endTime = \"\".concat(endHour.toString().padStart(2, '0'), \":\").concat(endMinute.toString().padStart(2, '0'));\n            slots.push(\"\".concat(startTime, \" - \").concat(endTime));\n            currentMinutes += durationMinutes;\n        }\n    }\n    return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n            numeric: true\n        }));\n}\n/**\n * Generate slots for a specific date using operating hours\n */ async function generateSlotsForDate(date, service) {\n    try {\n        // First try to get operating hours and global settings\n        const [hoursRes, settingsRes] = await Promise.all([\n            fetch('/api/operating-hours').catch(()=>({\n                    json: ()=>[]\n                })),\n            fetch('/api/global-settings').catch(()=>({\n                    json: ()=>null\n                }))\n        ]);\n        const operatingHours = await hoursRes.json();\n        const globalSettings = await settingsRes.json();\n        // If we have operating hours configured, use the new system\n        if (operatingHours.length > 0 && globalSettings) {\n            const weekday = new Date(date).getDay();\n            const baseSlots = generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday);\n            // Check for date-specific overrides\n            try {\n                const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                const overrides = await overridesRes.json();\n                if (Array.isArray(overrides) && overrides.length > 0) {\n                    const availableOverrides = overrides.filter((o)=>o.available && (!service || !o.service || o.service === service)).map((o)=>o.time);\n                    return availableOverrides.sort((a, b)=>a.localeCompare(b, 'en', {\n                            numeric: true\n                        }));\n                }\n            } catch (error) {\n                console.warn('Could not fetch date overrides:', error);\n            }\n            return baseSlots;\n        }\n        // Fallback to old system - use global timeslots\n        try {\n            const globalSlotsRes = await fetch('/api/global-timeslots');\n            const globalSlots = await globalSlotsRes.json();\n            if (Array.isArray(globalSlots) && globalSlots.length > 0) {\n                const weekday = new Date(date).getDay();\n                const slots = globalSlots.filter((s)=>Number(s.weekday) === Number(weekday)).map((s)=>s.time);\n                // Check for date-specific overrides\n                try {\n                    const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                    const overrides = await overridesRes.json();\n                    if (Array.isArray(overrides) && overrides.some((o)=>o.available)) {\n                        const available = overrides.filter((o)=>o.available).map((o)=>o.time);\n                        return available.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    }\n                } catch (error) {\n                    console.warn('Could not fetch date overrides:', error);\n                }\n                return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n                        numeric: true\n                    }));\n            }\n        } catch (error) {\n            console.warn('Could not fetch global timeslots:', error);\n        }\n        // Final fallback - return empty array\n        return [];\n    } catch (error) {\n        console.error('Error generating slots for date:', error);\n        return [];\n    }\n}\n/**\n * Filter out past slots if the date is today\n */ function filterPastSlots(slots, date) {\n    const today = new Date();\n    const selectedDate = new Date(date);\n    // If not today, return all slots\n    if (today.getFullYear() !== selectedDate.getFullYear() || today.getMonth() !== selectedDate.getMonth() || today.getDate() !== selectedDate.getDate()) {\n        return slots;\n    }\n    // Filter out past slots\n    const nowMinutes = today.getHours() * 60 + today.getMinutes();\n    return slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        const [hour, minute] = startTime.split(':').map(Number);\n        const slotMinutes = hour * 60 + minute;\n        return slotMinutes > nowMinutes;\n    });\n}\n/**\n * Remove already booked slots\n */ function filterBookedSlots(slots, bookedSlots) {\n    return slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        return !bookedSlots.includes(startTime);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZ0JBOztDQUVDLEdBQ00sU0FBU0EsZ0NBQ2RDLGNBQWdDLEVBQ2hDQyxjQUE4QixFQUM5QkMsT0FBZTtJQUVmLE1BQU1DLFdBQVdILGVBQWVJLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsT0FBTyxLQUFLQTtJQUV4RCxJQUFJLENBQUNDLFlBQVksQ0FBQ0EsU0FBU0csUUFBUSxJQUFJSCxTQUFTSSxhQUFhLENBQUNDLE1BQU0sS0FBSyxHQUFHO1FBQzFFLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUMsUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxrQkFBa0JULGVBQWVVLHNCQUFzQjtJQUU3RCxLQUFLLE1BQU1DLFlBQVlULFNBQVNJLGFBQWEsQ0FBRTtRQUM3QyxNQUFNLENBQUNNLFVBQVVDLFdBQVcsR0FBR0YsU0FBU0csUUFBUSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUNoRSxNQUFNLENBQUNDLFdBQVdDLFlBQVksR0FBR1IsU0FBU1MsU0FBUyxDQUFDTCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUVuRSxNQUFNSSxjQUFjVCxXQUFXLEtBQUtDO1FBQ3BDLE1BQU1TLGVBQWVKLFlBQVksS0FBS0M7UUFFdEMsc0NBQXNDO1FBQ3RDLElBQUlJLGlCQUFpQkY7UUFFckIsTUFBT0UsaUJBQWlCZCxtQkFBbUJhLGFBQWM7WUFDdkQsTUFBTUUsWUFBWUMsS0FBS0MsS0FBSyxDQUFDSCxpQkFBaUI7WUFDOUMsTUFBTUksY0FBY0osaUJBQWlCO1lBQ3JDLE1BQU1LLGFBQWFMLGlCQUFpQmQ7WUFDcEMsTUFBTW9CLFVBQVVKLEtBQUtDLEtBQUssQ0FBQ0UsYUFBYTtZQUN4QyxNQUFNRSxZQUFZRixhQUFhO1lBRS9CLE1BQU1HLFlBQVksR0FBNENKLE9BQXpDSCxVQUFVUSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxH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QUFNLENBQUNoRCxVQUFVLEdBQUdnRCxLQUFLaEUsS0FBSyxDQUFDO1FBQy9CLE1BQU0sQ0FBQ2lFLE1BQU1DLE9BQU8sR0FBR2xELFVBQVVoQixLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUNoRCxNQUFNaUUsY0FBY0YsT0FBTyxLQUFLQztRQUNoQyxPQUFPQyxjQUFjTjtJQUN2QjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTTyxrQkFBa0IzRSxLQUFlLEVBQUU0RSxXQUFxQjtJQUN0RSxPQUFPNUUsTUFBTW1ELE1BQU0sQ0FBQ29CLENBQUFBO1FBQ2xCLE1BQU0sQ0FBQ2hELFVBQVUsR0FBR2dELEtBQUtoRSxLQUFLLENBQUM7UUFDL0IsT0FBTyxDQUFDcUUsWUFBWUMsUUFBUSxDQUFDdEQ7SUFDL0I7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2tvbnN0YW50aW5vc2xlcGlkYXMvRGVza3RvcC9hdmdvdXN0ZS9hY3VwdW5jdHVyZS1ib29raW5nL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgVGltZUludGVydmFsIHtcbiAgaWQ6IHN0cmluZztcbiAgb3BlblRpbWU6IHN0cmluZztcbiAgY2xvc2VUaW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBPcGVyYXRpbmdIb3VycyB7XG4gIHdlZWtkYXk6IG51bWJlcjtcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIHRpbWVJbnRlcnZhbHM6IFRpbWVJbnRlcnZhbFtdO1xufVxuXG5pbnRlcmZhY2UgR2xvYmFsU2V0dGluZ3Mge1xuICBib29raW5nRHVyYXRpb25NaW51dGVzOiBudW1iZXI7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdGltZSBzbG90cyBiYXNlZCBvbiBvcGVyYXRpbmcgaG91cnMgYW5kIGJvb2tpbmcgZHVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2xvdHNGcm9tT3BlcmF0aW5nSG91cnMoXG4gIG9wZXJhdGluZ0hvdXJzOiBPcGVyYXRpbmdIb3Vyc1tdLFxuICBnbG9iYWxTZXR0aW5nczogR2xvYmFsU2V0dGluZ3MsXG4gIHdlZWtkYXk6IG51bWJlclxuKTogc3RyaW5nW10ge1xuICBjb25zdCBkYXlIb3VycyA9IG9wZXJhdGluZ0hvdXJzLmZpbmQoaCA9PiBoLndlZWtkYXkgPT09IHdlZWtkYXkpO1xuICBcbiAgaWYgKCFkYXlIb3VycyB8fCAhZGF5SG91cnMuaXNBY3RpdmUgfHwgZGF5SG91cnMudGltZUludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBzbG90czogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gZ2xvYmFsU2V0dGluZ3MuYm9va2luZ0R1cmF0aW9uTWludXRlcztcblxuICBmb3IgKGNvbnN0IGludGVydmFsIG9mIGRheUhvdXJzLnRpbWVJbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbb3BlbkhvdXIsIG9wZW5NaW51dGVdID0gaW50ZXJ2YWwub3BlblRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBjb25zdCBbY2xvc2VIb3VyLCBjbG9zZU1pbnV0ZV0gPSBpbnRlcnZhbC5jbG9zZVRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBcbiAgICBjb25zdCBvcGVuTWludXRlcyA9IG9wZW5Ib3VyICogNjAgKyBvcGVuTWludXRlO1xuICAgIGNvbnN0IGNsb3NlTWludXRlcyA9IGNsb3NlSG91ciAqIDYwICsgY2xvc2VNaW51dGU7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgc2xvdHMgd2l0aGluIHRoaXMgaW50ZXJ2YWxcbiAgICBsZXQgY3VycmVudE1pbnV0ZXMgPSBvcGVuTWludXRlcztcbiAgICBcbiAgICB3aGlsZSAoY3VycmVudE1pbnV0ZXMgKyBkdXJhdGlvbk1pbnV0ZXMgPD0gY2xvc2VNaW51dGVzKSB7XG4gICAgICBjb25zdCBzdGFydEhvdXIgPSBNYXRoLmZsb29yKGN1cnJlbnRNaW51dGVzIC8gNjApO1xuICAgICAgY29uc3Qgc3RhcnRNaW51dGUgPSBjdXJyZW50TWludXRlcyAlIDYwO1xuICAgICAgY29uc3QgZW5kTWludXRlcyA9IGN1cnJlbnRNaW51dGVzICsgZHVyYXRpb25NaW51dGVzO1xuICAgICAgY29uc3QgZW5kSG91ciA9IE1hdGguZmxvb3IoZW5kTWludXRlcyAvIDYwKTtcbiAgICAgIGNvbnN0IGVuZE1pbnV0ZSA9IGVuZE1pbnV0ZXMgJSA2MDtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gYCR7c3RhcnRIb3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtzdGFydE1pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBgJHtlbmRIb3VyLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtlbmRNaW51dGUudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gICAgICBcbiAgICAgIHNsb3RzLnB1c2goYCR7c3RhcnRUaW1lfSAtICR7ZW5kVGltZX1gKTtcbiAgICAgIFxuICAgICAgY3VycmVudE1pbnV0ZXMgKz0gZHVyYXRpb25NaW51dGVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzbG90cy5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJywgeyBudW1lcmljOiB0cnVlIH0pKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBzbG90cyBmb3IgYSBzcGVjaWZpYyBkYXRlIHVzaW5nIG9wZXJhdGluZyBob3Vyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTbG90c0ZvckRhdGUoXG4gIGRhdGU6IHN0cmluZyxcbiAgc2VydmljZT86IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0IHRyeSB0byBnZXQgb3BlcmF0aW5nIGhvdXJzIGFuZCBnbG9iYWwgc2V0dGluZ3NcbiAgICBjb25zdCBbaG91cnNSZXMsIHNldHRpbmdzUmVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZldGNoKCcvYXBpL29wZXJhdGluZy1ob3VycycpLmNhdGNoKCgpID0+ICh7IGpzb246ICgpID0+IFtdIH0pKSxcbiAgICAgIGZldGNoKCcvYXBpL2dsb2JhbC1zZXR0aW5ncycpLmNhdGNoKCgpID0+ICh7IGpzb246ICgpID0+IG51bGwgfSkpXG4gICAgXSk7XG4gICAgXG4gICAgY29uc3Qgb3BlcmF0aW5nSG91cnM6IE9wZXJhdGluZ0hvdXJzW10gPSBhd2FpdCBob3Vyc1Jlcy5qc29uKCk7XG4gICAgY29uc3QgZ2xvYmFsU2V0dGluZ3M6IEdsb2JhbFNldHRpbmdzID0gYXdhaXQgc2V0dGluZ3NSZXMuanNvbigpO1xuICAgIFxuICAgIC8vIElmIHdlIGhhdmUgb3BlcmF0aW5nIGhvdXJzIGNvbmZpZ3VyZWQsIHVzZSB0aGUgbmV3IHN5c3RlbVxuICAgIGlmIChvcGVyYXRpbmdIb3Vycy5sZW5ndGggPiAwICYmIGdsb2JhbFNldHRpbmdzKSB7XG4gICAgICBjb25zdCB3ZWVrZGF5ID0gbmV3IERhdGUoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICBjb25zdCBiYXNlU2xvdHMgPSBnZW5lcmF0ZVNsb3RzRnJvbU9wZXJhdGluZ0hvdXJzKG9wZXJhdGluZ0hvdXJzLCBnbG9iYWxTZXR0aW5ncywgd2Vla2RheSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBkYXRlLXNwZWNpZmljIG92ZXJyaWRlc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVzUmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0ZS1vdmVycmlkZXM/ZGF0ZT0ke2RhdGV9YCk7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IGF3YWl0IG92ZXJyaWRlc1Jlcy5qc29uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdmVycmlkZXMpICYmIG92ZXJyaWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgYXZhaWxhYmxlT3ZlcnJpZGVzID0gb3ZlcnJpZGVzXG4gICAgICAgICAgICAuZmlsdGVyKChvOiB7IGF2YWlsYWJsZTogYm9vbGVhbjsgc2VydmljZT86IHN0cmluZyB9KSA9PiBcbiAgICAgICAgICAgICAgby5hdmFpbGFibGUgJiYgKCFzZXJ2aWNlIHx8ICFvLnNlcnZpY2UgfHwgby5zZXJ2aWNlID09PSBzZXJ2aWNlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLm1hcCgobzogeyB0aW1lOiBzdHJpbmcgfSkgPT4gby50aW1lKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlT3ZlcnJpZGVzLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBcbiAgICAgICAgICAgIGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBkYXRlIG92ZXJyaWRlczonLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBiYXNlU2xvdHM7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIG9sZCBzeXN0ZW0gLSB1c2UgZ2xvYmFsIHRpbWVzbG90c1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnbG9iYWxTbG90c1JlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2dsb2JhbC10aW1lc2xvdHMnKTtcbiAgICAgIGNvbnN0IGdsb2JhbFNsb3RzID0gYXdhaXQgZ2xvYmFsU2xvdHNSZXMuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShnbG9iYWxTbG90cykgJiYgZ2xvYmFsU2xvdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3ZWVrZGF5ID0gbmV3IERhdGUoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICAgIGNvbnN0IHNsb3RzID0gZ2xvYmFsU2xvdHNcbiAgICAgICAgICAuZmlsdGVyKChzOiB7IHdlZWtkYXk6IG51bWJlciB9KSA9PiBOdW1iZXIocy53ZWVrZGF5KSA9PT0gTnVtYmVyKHdlZWtkYXkpKVxuICAgICAgICAgIC5tYXAoKHM6IHsgdGltZTogc3RyaW5nIH0pID0+IHMudGltZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBmb3IgZGF0ZS1zcGVjaWZpYyBvdmVycmlkZXNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvdmVycmlkZXNSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRlLW92ZXJyaWRlcz9kYXRlPSR7ZGF0ZX1gKTtcbiAgICAgICAgICBjb25zdCBvdmVycmlkZXMgPSBhd2FpdCBvdmVycmlkZXNSZXMuanNvbigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG92ZXJyaWRlcykgJiYgb3ZlcnJpZGVzLnNvbWUoKG86IHsgYXZhaWxhYmxlOiBib29sZWFuIH0pID0+IG8uYXZhaWxhYmxlKSkge1xuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gb3ZlcnJpZGVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoKG86IHsgYXZhaWxhYmxlOiBib29sZWFuIH0pID0+IG8uYXZhaWxhYmxlKVxuICAgICAgICAgICAgICAubWFwKChvOiB7IHRpbWU6IHN0cmluZyB9KSA9PiBvLnRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZS5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gYS5sb2NhbGVDb21wYXJlKGIsICdlbicsIHsgbnVtZXJpYzogdHJ1ZSB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIGRhdGUgb3ZlcnJpZGVzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNsb3RzLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJywgeyBudW1lcmljOiB0cnVlIH0pKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggZ2xvYmFsIHRpbWVzbG90czonLCBlcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmFsIGZhbGxiYWNrIC0gcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgcmV0dXJuIFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgc2xvdHMgZm9yIGRhdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEZpbHRlciBvdXQgcGFzdCBzbG90cyBpZiB0aGUgZGF0ZSBpcyB0b2RheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGFzdFNsb3RzKHNsb3RzOiBzdHJpbmdbXSwgZGF0ZTogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IHNlbGVjdGVkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICBcbiAgLy8gSWYgbm90IHRvZGF5LCByZXR1cm4gYWxsIHNsb3RzXG4gIGlmIChcbiAgICB0b2RheS5nZXRGdWxsWWVhcigpICE9PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKSB8fFxuICAgIHRvZGF5LmdldE1vbnRoKCkgIT09IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpIHx8XG4gICAgdG9kYXkuZ2V0RGF0ZSgpICE9PSBzZWxlY3RlZERhdGUuZ2V0RGF0ZSgpXG4gICkge1xuICAgIHJldHVybiBzbG90cztcbiAgfVxuICBcbiAgLy8gRmlsdGVyIG91dCBwYXN0IHNsb3RzXG4gIGNvbnN0IG5vd01pbnV0ZXMgPSB0b2RheS5nZXRIb3VycygpICogNjAgKyB0b2RheS5nZXRNaW51dGVzKCk7XG4gIFxuICByZXR1cm4gc2xvdHMuZmlsdGVyKHNsb3QgPT4ge1xuICAgIGNvbnN0IFtzdGFydFRpbWVdID0gc2xvdC5zcGxpdCgnIC0gJyk7XG4gICAgY29uc3QgW2hvdXIsIG1pbnV0ZV0gPSBzdGFydFRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBjb25zdCBzbG90TWludXRlcyA9IGhvdXIgKiA2MCArIG1pbnV0ZTtcbiAgICByZXR1cm4gc2xvdE1pbnV0ZXMgPiBub3dNaW51dGVzO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxyZWFkeSBib29rZWQgc2xvdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckJvb2tlZFNsb3RzKHNsb3RzOiBzdHJpbmdbXSwgYm9va2VkU2xvdHM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gc2xvdHMuZmlsdGVyKHNsb3QgPT4ge1xuICAgIGNvbnN0IFtzdGFydFRpbWVdID0gc2xvdC5zcGxpdCgnIC0gJyk7XG4gICAgcmV0dXJuICFib29rZWRTbG90cy5pbmNsdWRlcyhzdGFydFRpbWUpO1xuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZVNsb3RzRnJvbU9wZXJhdGluZ0hvdXJzIiwib3BlcmF0aW5nSG91cnMiLCJnbG9iYWxTZXR0aW5ncyIsIndlZWtkYXkiLCJkYXlIb3VycyIsImZpbmQiLCJoIiwiaXNBY3RpdmUiLCJ0aW1lSW50ZXJ2YWxzIiwibGVuZ3RoIiwic2xvdHMiLCJkdXJhdGlvbk1pbnV0ZXMiLCJib29raW5nRHVyYXRpb25NaW51dGVzIiwiaW50ZXJ2YWwiLCJvcGVuSG91ciIsIm9wZW5NaW51dGUiLCJvcGVuVGltZSIsInNwbGl0IiwibWFwIiwiTnVtYmVyIiwiY2xvc2VIb3VyIiwiY2xvc2VNaW51dGUiLCJjbG9zZVRpbWUiLCJvcGVuTWludXRlcyIsImNsb3NlTWludXRlcyIsImN1cnJlbnRNaW51dGVzIiwic3RhcnRIb3VyIiwiTWF0aCIsImZsb29yIiwic3RhcnRNaW51dGUiLCJlbmRNaW51dGVzIiwiZW5kSG91ciIsImVuZE1pbnV0ZSIsInN0YXJ0VGltZSIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJlbmRUaW1lIiwicHVzaCIsInNvcnQiLCJhIiwiYiIsImxvY2FsZUNvbXBhcmUiLCJudW1lcmljIiwiZ2VuZXJhdGVTbG90c0ZvckRhdGUiLCJkYXRlIiwic2VydmljZSIsImhvdXJzUmVzIiwic2V0dGluZ3NSZXMiLCJQcm9taXNlIiwiYWxsIiwiZmV0Y2giLCJjYXRjaCIsImpzb24iLCJEYXRlIiwiZ2V0RGF5IiwiYmFzZVNsb3RzIiwib3ZlcnJpZGVzUmVzIiwib3ZlcnJpZGVzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXZhaWxhYmxlT3ZlcnJpZGVzIiwiZmlsdGVyIiwibyIsImF2YWlsYWJsZSIsInRpbWUiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZ2xvYmFsU2xvdHNSZXMiLCJnbG9iYWxTbG90cyIsInMiLCJzb21lIiwiZmlsdGVyUGFzdFNsb3RzIiwidG9kYXkiLCJzZWxlY3RlZERhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsIm5vd01pbnV0ZXMiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJzbG90IiwiaG91ciIsIm1pbnV0ZSIsInNsb3RNaW51dGVzIiwiZmlsdGVyQm9va2VkU2xvdHMiLCJib29rZWRTbG90cyIsImluY2x1ZGVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/slotGenerator.ts\n"));

/***/ })

});