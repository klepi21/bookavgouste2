"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/slotGenerator.ts":
/*!**********************************!*\
  !*** ./src/lib/slotGenerator.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterBookedSlots: () => (/* binding */ filterBookedSlots),\n/* harmony export */   filterPastSlots: () => (/* binding */ filterPastSlots),\n/* harmony export */   generateSlotsForDate: () => (/* binding */ generateSlotsForDate),\n/* harmony export */   generateSlotsFromOperatingHours: () => (/* binding */ generateSlotsFromOperatingHours)\n/* harmony export */ });\n/**\n * Generate time slots based on operating hours and booking duration\n */ function generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday) {\n    const dayHours = operatingHours.find((h)=>h.weekday === weekday);\n    if (!dayHours || !dayHours.isActive || dayHours.timeIntervals.length === 0) {\n        return [];\n    }\n    const slots = [];\n    const durationMinutes = globalSettings.bookingDurationMinutes;\n    for (const interval of dayHours.timeIntervals){\n        const [openHour, openMinute] = interval.openTime.split(':').map(Number);\n        const [closeHour, closeMinute] = interval.closeTime.split(':').map(Number);\n        const openMinutes = openHour * 60 + openMinute;\n        const closeMinutes = closeHour * 60 + closeMinute;\n        // Generate slots within this interval\n        let currentMinutes = openMinutes;\n        while(currentMinutes + durationMinutes <= closeMinutes){\n            const startHour = Math.floor(currentMinutes / 60);\n            const startMinute = currentMinutes % 60;\n            const endMinutes = currentMinutes + durationMinutes;\n            const endHour = Math.floor(endMinutes / 60);\n            const endMinute = endMinutes % 60;\n            const startTime = \"\".concat(startHour.toString().padStart(2, '0'), \":\").concat(startMinute.toString().padStart(2, '0'));\n            const endTime = \"\".concat(endHour.toString().padStart(2, '0'), \":\").concat(endMinute.toString().padStart(2, '0'));\n            slots.push(\"\".concat(startTime, \" - \").concat(endTime));\n            currentMinutes += durationMinutes;\n        }\n    }\n    return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n            numeric: true\n        }));\n}\n/**\n * Generate slots for a specific date using operating hours\n */ async function generateSlotsForDate(date, service) {\n    try {\n        console.log('ðŸ” Generating slots for date:', date, 'service:', service);\n        // First try to get operating hours and global settings\n        const [hoursRes, settingsRes] = await Promise.all([\n            fetch('/api/operating-hours').catch(()=>({\n                    json: ()=>[]\n                })),\n            fetch('/api/global-settings').catch(()=>({\n                    json: ()=>null\n                }))\n        ]);\n        const operatingHours = await hoursRes.json();\n        const globalSettings = await settingsRes.json();\n        console.log('ðŸ“Š Operating hours:', operatingHours);\n        console.log('âš™ï¸ Global settings:', globalSettings);\n        // If we have operating hours configured, use the new system\n        if (operatingHours.length > 0 && globalSettings && operatingHours.some((h)=>h.isActive && h.timeIntervals.length > 0)) {\n            const weekday = new Date(date).getDay();\n            const baseSlots = generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday);\n            // Check for date-specific overrides\n            try {\n                const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                const overrides = await overridesRes.json();\n                if (Array.isArray(overrides) && overrides.length > 0) {\n                    const availableOverrides = overrides.filter((o)=>o.available && (!service || !o.service || o.service === service)).map((o)=>o.time);\n                    return availableOverrides.sort((a, b)=>a.localeCompare(b, 'en', {\n                            numeric: true\n                        }));\n                }\n            } catch (error) {\n                console.warn('Could not fetch date overrides:', error);\n            }\n            return baseSlots;\n        }\n        // Fallback to old system - use global timeslots\n        try {\n            const globalSlotsRes = await fetch('/api/global-timeslots');\n            const globalSlots = await globalSlotsRes.json();\n            if (Array.isArray(globalSlots) && globalSlots.length > 0) {\n                const weekday = new Date(date).getDay();\n                const slots = globalSlots.filter((s)=>Number(s.weekday) === Number(weekday)).map((s)=>s.time);\n                // Check for date-specific overrides\n                try {\n                    const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                    const overrides = await overridesRes.json();\n                    if (Array.isArray(overrides) && overrides.some((o)=>o.available)) {\n                        const available = overrides.filter((o)=>o.available).map((o)=>o.time);\n                        return available.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    }\n                } catch (error) {\n                    console.warn('Could not fetch date overrides:', error);\n                }\n                return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n                        numeric: true\n                    }));\n            }\n        } catch (error) {\n            console.warn('Could not fetch global timeslots:', error);\n        }\n        // Final fallback - return empty array\n        return [];\n    } catch (error) {\n        console.error('Error generating slots for date:', error);\n        return [];\n    }\n}\n/**\n * Filter out past slots if the date is today\n */ function filterPastSlots(slots, date) {\n    const today = new Date();\n    const selectedDate = new Date(date);\n    // If not today, return all slots\n    if (today.getFullYear() !== selectedDate.getFullYear() || today.getMonth() !== selectedDate.getMonth() || today.getDate() !== selectedDate.getDate()) {\n        return slots;\n    }\n    // Filter out past slots\n    const nowMinutes = today.getHours() * 60 + today.getMinutes();\n    return slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        const [hour, minute] = startTime.split(':').map(Number);\n        const slotMinutes = hour * 60 + minute;\n        return slotMinutes > nowMinutes;\n    });\n}\n/**\n * Remove already booked slots\n */ function filterBookedSlots(slots, bookedSlots) {\n    return slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        return !bookedSlots.includes(startTime);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZ0JBOztDQUVDLEdBQ00sU0FBU0EsZ0NBQ2RDLGNBQWdDLEVBQ2hDQyxjQUE4QixFQUM5QkMsT0FBZTtJQUVmLE1BQU1DLFdBQVdILGVBQWVJLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsT0FBTyxLQUFLQTtJQUV4RCxJQUFJLENBQUNDLFlBQVksQ0FBQ0EsU0FBU0csUUFBUSxJQUFJSCxTQUFTSSxhQUFhLENBQUNDLE1BQU0sS0FBSyxHQUFHO1FBQzFFLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUMsUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxrQkFBa0JULGVBQWVVLHNCQUFzQjtJQUU3RCxLQUFLLE1BQU1DLFlBQVlULFNBQVNJLGFBQWEsQ0FBRTtRQUM3QyxNQUFNLENBQUNNLFVBQVVDLFdBQVcsR0FBR0YsU0FBU0csUUFBUSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUNoRSxNQUFNLENBQUNDLFdBQVdDLFlBQVksR0FBR1IsU0FBU1MsU0FBUyxDQUFDTCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUVuRSxNQUFNSSxjQUFjVCxXQUFXLEtBQUtDO1FBQ3BDLE1BQU1TLGVBQWVKLFlBQVksS0FBS0M7UUFFdEMsc0NBQXNDO1FBQ3RDLElBQUlJLGlCQUFpQkY7UUFFckIsTUFBT0UsaUJBQWlCZCxtQkFBbUJhLGFBQWM7WUFDdkQsTUFBTUUsWUFBWUMsS0FBS0MsS0FBSyxDQUFDSCxpQkFBaUI7WUFDOUMsTUFBTUksY0FBY0osaUJBQWlCO1lBQ3JDLE1BQU1LLGFBQWFMLGlCQUFpQmQ7WUFDcEMsTUFBTW9CLFVBQVVKLEtBQUtDLEtBQUssQ0FBQ0UsYUFBYTtZQUN4QyxNQUFNRSxZQUFZRixhQUFhO1lBRS9CLE1BQU1HLFlBQVksR0FBNENKLE9BQXpDSCxVQUFVUSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxH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RixNQUFNRyxRQUFRLE9BQU9GLGFBQWFFLFFBQVEsTUFDMUNILE1BQU1JLE9BQU8sT0FBT0gsYUFBYUcsT0FBTyxJQUN4QztRQUNBLE9BQU9wRTtJQUNUO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU1xRSxhQUFhTCxNQUFNTSxRQUFRLEtBQUssS0FBS04sTUFBTU8sVUFBVTtJQUUzRCxPQUFPdkUsTUFBTXNELE1BQU0sQ0FBQ2tCLENBQUFBO1FBQ2xCLE1BQU0sQ0FBQ2pELFVBQVUsR0FBR2lELEtBQUtqRSxLQUFLLENBQUM7UUFDL0IsTUFBTSxDQUFDa0UsTUFBTUMsT0FBTyxHQUFHbkQsVUFBVWhCLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDO1FBQ2hELE1BQU1rRSxjQUFjRixPQUFPLEtBQUtDO1FBQ2hDLE9BQU9DLGNBQWNOO0lBQ3ZCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNPLGtCQUFrQjVFLEtBQWUsRUFBRTZFLFdBQXFCO0lBQ3RFLE9BQU83RSxNQUFNc0QsTUFBTSxDQUFDa0IsQ0FBQUE7UUFDbEIsTUFBTSxDQUFDakQsVUFBVSxHQUFHaUQsS0FBS2pFLEtBQUssQ0FBQztRQUMvQixPQUFPLENBQUNzRSxZQUFZQyxRQUFRLENBQUN2RDtJQUMvQjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMva29uc3RhbnRpbm9zbGVwaWRhcy9EZXNrdG9wL2F2Z291c3RlL2FjdXB1bmN0dXJlLWJvb2tpbmcvc3JjL2xpYi9zbG90R2VuZXJhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBUaW1lSW50ZXJ2YWwge1xuICBpZDogc3RyaW5nO1xuICBvcGVuVGltZTogc3RyaW5nO1xuICBjbG9zZVRpbWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE9wZXJhdGluZ0hvdXJzIHtcbiAgd2Vla2RheTogbnVtYmVyO1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgdGltZUludGVydmFsczogVGltZUludGVydmFsW107XG59XG5cbmludGVyZmFjZSBHbG9iYWxTZXR0aW5ncyB7XG4gIGJvb2tpbmdEdXJhdGlvbk1pbnV0ZXM6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aW1lIHNsb3RzIGJhc2VkIG9uIG9wZXJhdGluZyBob3VycyBhbmQgYm9va2luZyBkdXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTbG90c0Zyb21PcGVyYXRpbmdIb3VycyhcbiAgb3BlcmF0aW5nSG91cnM6IE9wZXJhdGluZ0hvdXJzW10sXG4gIGdsb2JhbFNldHRpbmdzOiBHbG9iYWxTZXR0aW5ncyxcbiAgd2Vla2RheTogbnVtYmVyXG4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGRheUhvdXJzID0gb3BlcmF0aW5nSG91cnMuZmluZChoID0+IGgud2Vla2RheSA9PT0gd2Vla2RheSk7XG4gIFxuICBpZiAoIWRheUhvdXJzIHx8ICFkYXlIb3Vycy5pc0FjdGl2ZSB8fCBkYXlIb3Vycy50aW1lSW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHNsb3RzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBkdXJhdGlvbk1pbnV0ZXMgPSBnbG9iYWxTZXR0aW5ncy5ib29raW5nRHVyYXRpb25NaW51dGVzO1xuXG4gIGZvciAoY29uc3QgaW50ZXJ2YWwgb2YgZGF5SG91cnMudGltZUludGVydmFscykge1xuICAgIGNvbnN0IFtvcGVuSG91ciwgb3Blbk1pbnV0ZV0gPSBpbnRlcnZhbC5vcGVuVGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IFtjbG9zZUhvdXIsIGNsb3NlTWludXRlXSA9IGludGVydmFsLmNsb3NlVGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgIFxuICAgIGNvbnN0IG9wZW5NaW51dGVzID0gb3BlbkhvdXIgKiA2MCArIG9wZW5NaW51dGU7XG4gICAgY29uc3QgY2xvc2VNaW51dGVzID0gY2xvc2VIb3VyICogNjAgKyBjbG9zZU1pbnV0ZTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBzbG90cyB3aXRoaW4gdGhpcyBpbnRlcnZhbFxuICAgIGxldCBjdXJyZW50TWludXRlcyA9IG9wZW5NaW51dGVzO1xuICAgIFxuICAgIHdoaWxlIChjdXJyZW50TWludXRlcyArIGR1cmF0aW9uTWludXRlcyA8PSBjbG9zZU1pbnV0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0SG91ciA9IE1hdGguZmxvb3IoY3VycmVudE1pbnV0ZXMgLyA2MCk7XG4gICAgICBjb25zdCBzdGFydE1pbnV0ZSA9IGN1cnJlbnRNaW51dGVzICUgNjA7XG4gICAgICBjb25zdCBlbmRNaW51dGVzID0gY3VycmVudE1pbnV0ZXMgKyBkdXJhdGlvbk1pbnV0ZXM7XG4gICAgICBjb25zdCBlbmRIb3VyID0gTWF0aC5mbG9vcihlbmRNaW51dGVzIC8gNjApO1xuICAgICAgY29uc3QgZW5kTWludXRlID0gZW5kTWludXRlcyAlIDYwO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBgJHtzdGFydEhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3N0YXJ0TWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICAgICAgY29uc3QgZW5kVGltZSA9IGAke2VuZEhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2VuZE1pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAgIFxuICAgICAgc2xvdHMucHVzaChgJHtzdGFydFRpbWV9IC0gJHtlbmRUaW1lfWApO1xuICAgICAgXG4gICAgICBjdXJyZW50TWludXRlcyArPSBkdXJhdGlvbk1pbnV0ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNsb3RzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSkpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHNsb3RzIGZvciBhIHNwZWNpZmljIGRhdGUgdXNpbmcgb3BlcmF0aW5nIGhvdXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNsb3RzRm9yRGF0ZShcbiAgZGF0ZTogc3RyaW5nLFxuICBzZXJ2aWNlPzogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ/CflI0gR2VuZXJhdGluZyBzbG90cyBmb3IgZGF0ZTonLCBkYXRlLCAnc2VydmljZTonLCBzZXJ2aWNlKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IG9wZXJhdGluZyBob3VycyBhbmQgZ2xvYmFsIHNldHRpbmdzXG4gICAgY29uc3QgW2hvdXJzUmVzLCBzZXR0aW5nc1Jlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBmZXRjaCgnL2FwaS9vcGVyYXRpbmctaG91cnMnKS5jYXRjaCgoKSA9PiAoeyBqc29uOiAoKSA9PiBbXSB9KSksXG4gICAgICBmZXRjaCgnL2FwaS9nbG9iYWwtc2V0dGluZ3MnKS5jYXRjaCgoKSA9PiAoeyBqc29uOiAoKSA9PiBudWxsIH0pKVxuICAgIF0pO1xuICAgIFxuICAgIGNvbnN0IG9wZXJhdGluZ0hvdXJzOiBPcGVyYXRpbmdIb3Vyc1tdID0gYXdhaXQgaG91cnNSZXMuanNvbigpO1xuICAgIGNvbnN0IGdsb2JhbFNldHRpbmdzOiBHbG9iYWxTZXR0aW5ncyA9IGF3YWl0IHNldHRpbmdzUmVzLmpzb24oKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygn8J+TiiBPcGVyYXRpbmcgaG91cnM6Jywgb3BlcmF0aW5nSG91cnMpO1xuICAgIGNvbnNvbGUubG9nKCfimpnvuI8gR2xvYmFsIHNldHRpbmdzOicsIGdsb2JhbFNldHRpbmdzKTtcbiAgICBcbiAgICAvLyBJZiB3ZSBoYXZlIG9wZXJhdGluZyBob3VycyBjb25maWd1cmVkLCB1c2UgdGhlIG5ldyBzeXN0ZW1cbiAgICBpZiAob3BlcmF0aW5nSG91cnMubGVuZ3RoID4gMCAmJiBnbG9iYWxTZXR0aW5ncyAmJiBvcGVyYXRpbmdIb3Vycy5zb21lKGggPT4gaC5pc0FjdGl2ZSAmJiBoLnRpbWVJbnRlcnZhbHMubGVuZ3RoID4gMCkpIHtcbiAgICAgIGNvbnN0IHdlZWtkYXkgPSBuZXcgRGF0ZShkYXRlKS5nZXREYXkoKTtcbiAgICAgIGNvbnN0IGJhc2VTbG90cyA9IGdlbmVyYXRlU2xvdHNGcm9tT3BlcmF0aW5nSG91cnMob3BlcmF0aW5nSG91cnMsIGdsb2JhbFNldHRpbmdzLCB3ZWVrZGF5KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgZm9yIGRhdGUtc3BlY2lmaWMgb3ZlcnJpZGVzXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvdmVycmlkZXNSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRlLW92ZXJyaWRlcz9kYXRlPSR7ZGF0ZX1gKTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gYXdhaXQgb3ZlcnJpZGVzUmVzLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG92ZXJyaWRlcykgJiYgb3ZlcnJpZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGVPdmVycmlkZXMgPSBvdmVycmlkZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKG86IHsgYXZhaWxhYmxlOiBib29sZWFuOyBzZXJ2aWNlPzogc3RyaW5nIH0pID0+IFxuICAgICAgICAgICAgICBvLmF2YWlsYWJsZSAmJiAoIXNlcnZpY2UgfHwgIW8uc2VydmljZSB8fCBvLnNlcnZpY2UgPT09IHNlcnZpY2UpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKChvOiB7IHRpbWU6IHN0cmluZyB9KSA9PiBvLnRpbWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBhdmFpbGFibGVPdmVycmlkZXMuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IFxuICAgICAgICAgICAgYS5sb2NhbGVDb21wYXJlKGIsICdlbicsIHsgbnVtZXJpYzogdHJ1ZSB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIGRhdGUgb3ZlcnJpZGVzOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGJhc2VTbG90cztcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gb2xkIHN5c3RlbSAtIHVzZSBnbG9iYWwgdGltZXNsb3RzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGdsb2JhbFNsb3RzUmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZ2xvYmFsLXRpbWVzbG90cycpO1xuICAgICAgY29uc3QgZ2xvYmFsU2xvdHMgPSBhd2FpdCBnbG9iYWxTbG90c1Jlcy5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdsb2JhbFNsb3RzKSAmJiBnbG9iYWxTbG90cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdlZWtkYXkgPSBuZXcgRGF0ZShkYXRlKS5nZXREYXkoKTtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSBnbG9iYWxTbG90c1xuICAgICAgICAgIC5maWx0ZXIoKHM6IHsgd2Vla2RheTogbnVtYmVyIH0pID0+IE51bWJlcihzLndlZWtkYXkpID09PSBOdW1iZXIod2Vla2RheSkpXG4gICAgICAgICAgLm1hcCgoczogeyB0aW1lOiBzdHJpbmcgfSkgPT4gcy50aW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciBkYXRlLXNwZWNpZmljIG92ZXJyaWRlc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlc1JlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGUtb3ZlcnJpZGVzP2RhdGU9JHtkYXRlfWApO1xuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IGF3YWl0IG92ZXJyaWRlc1Jlcy5qc29uKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3ZlcnJpZGVzKSAmJiBvdmVycmlkZXMuc29tZSgobzogeyBhdmFpbGFibGU6IGJvb2xlYW4gfSkgPT4gby5hdmFpbGFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSBvdmVycmlkZXNcbiAgICAgICAgICAgICAgLmZpbHRlcigobzogeyBhdmFpbGFibGU6IGJvb2xlYW4gfSkgPT4gby5hdmFpbGFibGUpXG4gICAgICAgICAgICAgIC5tYXAoKG86IHsgdGltZTogc3RyaW5nIH0pID0+IG8udGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJywgeyBudW1lcmljOiB0cnVlIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggZGF0ZSBvdmVycmlkZXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2xvdHMuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBnbG9iYWwgdGltZXNsb3RzOicsIGVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluYWwgZmFsbGJhY2sgLSByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICByZXR1cm4gW107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBzbG90cyBmb3IgZGF0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRmlsdGVyIG91dCBwYXN0IHNsb3RzIGlmIHRoZSBkYXRlIGlzIHRvZGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXN0U2xvdHMoc2xvdHM6IHN0cmluZ1tdLCBkYXRlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3Qgc2VsZWN0ZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIFxuICAvLyBJZiBub3QgdG9kYXksIHJldHVybiBhbGwgc2xvdHNcbiAgaWYgKFxuICAgIHRvZGF5LmdldEZ1bGxZZWFyKCkgIT09IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpIHx8XG4gICAgdG9kYXkuZ2V0TW9udGgoKSAhPT0gc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgfHxcbiAgICB0b2RheS5nZXREYXRlKCkgIT09IHNlbGVjdGVkRGF0ZS5nZXREYXRlKClcbiAgKSB7XG4gICAgcmV0dXJuIHNsb3RzO1xuICB9XG4gIFxuICAvLyBGaWx0ZXIgb3V0IHBhc3Qgc2xvdHNcbiAgY29uc3Qgbm93TWludXRlcyA9IHRvZGF5LmdldEhvdXJzKCkgKiA2MCArIHRvZGF5LmdldE1pbnV0ZXMoKTtcbiAgXG4gIHJldHVybiBzbG90cy5maWx0ZXIoc2xvdCA9PiB7XG4gICAgY29uc3QgW3N0YXJ0VGltZV0gPSBzbG90LnNwbGl0KCcgLSAnKTtcbiAgICBjb25zdCBbaG91ciwgbWludXRlXSA9IHN0YXJ0VGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IHNsb3RNaW51dGVzID0gaG91ciAqIDYwICsgbWludXRlO1xuICAgIHJldHVybiBzbG90TWludXRlcyA+IG5vd01pbnV0ZXM7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbHJlYWR5IGJvb2tlZCBzbG90c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyQm9va2VkU2xvdHMoc2xvdHM6IHN0cmluZ1tdLCBib29rZWRTbG90czogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBzbG90cy5maWx0ZXIoc2xvdCA9PiB7XG4gICAgY29uc3QgW3N0YXJ0VGltZV0gPSBzbG90LnNwbGl0KCcgLSAnKTtcbiAgICByZXR1cm4gIWJvb2tlZFNsb3RzLmluY2x1ZGVzKHN0YXJ0VGltZSk7XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbImdlbmVyYXRlU2xvdHNGcm9tT3BlcmF0aW5nSG91cnMiLCJvcGVyYXRpbmdIb3VycyIsImdsb2JhbFNldHRpbmdzIiwid2Vla2RheSIsImRheUhvdXJzIiwiZmluZCIsImgiLCJpc0FjdGl2ZSIsInRpbWVJbnRlcnZhbHMiLCJsZW5ndGgiLCJzbG90cyIsImR1cmF0aW9uTWludXRlcyIsImJvb2tpbmdEdXJhdGlvbk1pbnV0ZXMiLCJpbnRlcnZhbCIsIm9wZW5Ib3VyIiwib3Blbk1pbnV0ZSIsIm9wZW5UaW1lIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJjbG9zZUhvdXIiLCJjbG9zZU1pbnV0ZSIsImNsb3NlVGltZSIsIm9wZW5NaW51dGVzIiwiY2xvc2VNaW51dGVzIiwiY3VycmVudE1pbnV0ZXMiLCJzdGFydEhvdXIiLCJNYXRoIiwiZmxvb3IiLCJzdGFydE1pbnV0ZSIsImVuZE1pbnV0ZXMiLCJlbmRIb3VyIiwiZW5kTWludXRlIiwic3RhcnRUaW1lIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImVuZFRpbWUiLCJwdXNoIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsIm51bWVyaWMiLCJnZW5lcmF0ZVNsb3RzRm9yRGF0ZSIsImRhdGUiLCJzZXJ2aWNlIiwiY29uc29sZSIsImxvZyIsImhvdXJzUmVzIiwic2V0dGluZ3NSZXMiLCJQcm9taXNlIiwiYWxsIiwiZmV0Y2giLCJjYXRjaCIsImpzb24iLCJzb21lIiwiRGF0ZSIsImdldERheSIsImJhc2VTbG90cyIsIm92ZXJyaWRlc1JlcyIsIm92ZXJyaWRlcyIsIkFycmF5IiwiaXNBcnJheSIsImF2YWlsYWJsZU92ZXJyaWRlcyIsImZpbHRlciIsIm8iLCJhdmFpbGFibGUiLCJ0aW1lIiwiZXJyb3IiLCJ3YXJuIiwiZ2xvYmFsU2xvdHNSZXMiLCJnbG9iYWxTbG90cyIsInMiLCJmaWx0ZXJQYXN0U2xvdHMiLCJ0b2RheSIsInNlbGVjdGVkRGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwibm93TWludXRlcyIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsInNsb3QiLCJob3VyIiwibWludXRlIiwic2xvdE1pbnV0ZXMiLCJmaWx0ZXJCb29rZWRTbG90cyIsImJvb2tlZFNsb3RzIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/slotGenerator.ts\n"));

/***/ })

});