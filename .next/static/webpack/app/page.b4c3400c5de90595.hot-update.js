"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/slotGenerator.ts":
/*!**********************************!*\
  !*** ./src/lib/slotGenerator.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   filterBookedSlots: () => (/* binding */ filterBookedSlots),\n/* harmony export */   filterPastSlots: () => (/* binding */ filterPastSlots),\n/* harmony export */   generateSlotsForDate: () => (/* binding */ generateSlotsForDate),\n/* harmony export */   generateSlotsFromOperatingHours: () => (/* binding */ generateSlotsFromOperatingHours)\n/* harmony export */ });\n/**\n * Generate time slots based on operating hours and booking duration\n */ function generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday) {\n    const dayHours = operatingHours.find((h)=>h.weekday === weekday);\n    if (!dayHours || !dayHours.isActive || dayHours.timeIntervals.length === 0) {\n        return [];\n    }\n    const slots = [];\n    const durationMinutes = globalSettings.bookingDurationMinutes;\n    for (const interval of dayHours.timeIntervals){\n        const [openHour, openMinute] = interval.openTime.split(':').map(Number);\n        const [closeHour, closeMinute] = interval.closeTime.split(':').map(Number);\n        const openMinutes = openHour * 60 + openMinute;\n        const closeMinutes = closeHour * 60 + closeMinute;\n        // Generate slots within this interval\n        let currentMinutes = openMinutes;\n        while(currentMinutes + durationMinutes < closeMinutes){\n            const startHour = Math.floor(currentMinutes / 60);\n            const startMinute = currentMinutes % 60;\n            const endMinutes = currentMinutes + durationMinutes;\n            const endHour = Math.floor(endMinutes / 60);\n            const endMinute = endMinutes % 60;\n            const startTime = \"\".concat(startHour.toString().padStart(2, '0'), \":\").concat(startMinute.toString().padStart(2, '0'));\n            const endTime = \"\".concat(endHour.toString().padStart(2, '0'), \":\").concat(endMinute.toString().padStart(2, '0'));\n            slots.push(\"\".concat(startTime, \" - \").concat(endTime));\n            currentMinutes += durationMinutes;\n        }\n    }\n    return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n            numeric: true\n        }));\n}\n/**\n * Generate slots for a specific date using operating hours\n */ async function generateSlotsForDate(date, service) {\n    try {\n        // console.log('üîç Generating slots for date:', date, 'service:', service);\n        // First try to get operating hours and global settings\n        const [hoursRes, settingsRes] = await Promise.all([\n            fetch('/api/operating-hours').catch(()=>({\n                    json: ()=>[]\n                })),\n            fetch('/api/global-settings').catch(()=>({\n                    json: ()=>null\n                }))\n        ]);\n        const operatingHours = await hoursRes.json();\n        const globalSettings = await settingsRes.json();\n        // console.log('üìä Operating hours:', operatingHours);\n        // console.log('‚öôÔ∏è Global settings:', globalSettings);\n        // If we have operating hours configured, use the new system\n        if (operatingHours.length > 0 && globalSettings && operatingHours.some((h)=>h.isActive && h.timeIntervals.length > 0)) {\n            // console.log('‚úÖ Using new operating hours system');\n            const weekday = new Date(date).getDay();\n            const baseSlots = generateSlotsFromOperatingHours(operatingHours, globalSettings, weekday);\n            // console.log('üéØ Generated base slots:', baseSlots);\n            // Check for date-specific overrides\n            try {\n                // console.log('üîç Checking for date overrides for date:', date);\n                const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                const overrides = await overridesRes.json();\n                // console.log('üìã Date overrides found:', overrides);\n                if (Array.isArray(overrides) && overrides.length > 0) {\n                    const availableOverrides = overrides.filter((o)=>o.available && (!service || !o.service || o.service === service)).map((o)=>o.time);\n                    // console.log('‚úÖ Available overrides:', availableOverrides);\n                    if (availableOverrides.length > 0) {\n                        return availableOverrides.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    } else {\n                    // console.log('‚ö†Ô∏è No available overrides found, using base slots instead');\n                    }\n                } else {\n                // console.log('üìÖ No date overrides found, using base slots');\n                }\n            } catch (error) {\n            // console.warn('Could not fetch date overrides:', error);\n            }\n            // Check for blocked intervals\n            try {\n                // console.log('üîç Checking for blocked intervals for date:', date);\n                const blockedRes = await fetch(\"/api/blocked-intervals?date=\".concat(date));\n                const blockedIntervals = await blockedRes.json();\n                // console.log('üö´ Blocked intervals found:', blockedIntervals);\n                if (Array.isArray(blockedIntervals) && blockedIntervals.length > 0) {\n                    // Filter out slots that overlap with blocked intervals\n                    const filteredSlots = baseSlots.filter((slot)=>{\n                        const [slotStart, slotEnd] = slot.split(' - ');\n                        const slotStartMinutes = timeToMinutes(slotStart);\n                        const slotEndMinutes = timeToMinutes(slotEnd);\n                        const hasOverlap = blockedIntervals.some((interval)=>{\n                            const intervalStartMinutes = timeToMinutes(interval.startTime);\n                            const intervalEndMinutes = timeToMinutes(interval.endTime);\n                            const overlaps = slotStartMinutes < intervalEndMinutes && slotEndMinutes > intervalStartMinutes;\n                            if (overlaps) {\n                            // console.log(`üö´ Slot ${slot} overlaps with blocked interval ${interval.startTime}-${interval.endTime} (${interval.reason || 'No reason'})`);\n                            }\n                            return overlaps;\n                        });\n                        return !hasOverlap;\n                    });\n                    // console.log('‚úÖ Slots after blocked intervals filter:', filteredSlots);\n                    return filteredSlots;\n                } else {\n                // console.log('üìÖ No blocked intervals found, using base slots');\n                }\n            } catch (error) {\n            // console.warn('Could not fetch blocked intervals:', error);\n            }\n            // console.log('üéØ Returning baseSlots from new system:', baseSlots);\n            return baseSlots;\n        }\n        // Fallback to old system - use global timeslots\n        // console.log('üîÑ Falling back to old global timeslots system');\n        try {\n            const globalSlotsRes = await fetch('/api/global-timeslots');\n            const globalSlots = await globalSlotsRes.json();\n            // console.log('üìÖ Global slots from old system:', globalSlots);\n            if (Array.isArray(globalSlots) && globalSlots.length > 0) {\n                const weekday = new Date(date).getDay();\n                const slots = globalSlots.filter((s)=>Number(s.weekday) === Number(weekday)).map((s)=>s.time);\n                // Check for date-specific overrides\n                try {\n                    const overridesRes = await fetch(\"/api/date-overrides?date=\".concat(date));\n                    const overrides = await overridesRes.json();\n                    if (Array.isArray(overrides) && overrides.some((o)=>o.available)) {\n                        const available = overrides.filter((o)=>o.available).map((o)=>o.time);\n                        return available.sort((a, b)=>a.localeCompare(b, 'en', {\n                                numeric: true\n                            }));\n                    }\n                } catch (error) {\n                // console.warn('Could not fetch date overrides:', error);\n                }\n                return slots.sort((a, b)=>a.localeCompare(b, 'en', {\n                        numeric: true\n                    }));\n            }\n        } catch (error) {\n        // console.warn('Could not fetch global timeslots:', error);\n        }\n        // Final fallback - return empty array\n        // console.log('‚ùå No slots found for date:', date);\n        return [];\n    } catch (error) {\n        // console.error('‚ùå Error generating slots for date:', error);\n        return [];\n    }\n}\n/**\n * Filter out past slots if the date is today\n */ function filterPastSlots(slots, date) {\n    const today = new Date();\n    const selectedDate = new Date(date);\n    // console.log('üïê Filtering past slots. Date:', date, 'Today:', today.toISOString().split('T')[0]);\n    // If not today, return all slots\n    if (today.getFullYear() !== selectedDate.getFullYear() || today.getMonth() !== selectedDate.getMonth() || today.getDate() !== selectedDate.getDate()) {\n        // console.log('üìÖ Not today, returning all slots:', slots);\n        return slots;\n    }\n    // Filter out past slots\n    const nowMinutes = today.getHours() * 60 + today.getMinutes();\n    // console.log('‚è∞ Current time in minutes:', nowMinutes);\n    const filtered = slots.filter((slot)=>{\n        const [startTime] = slot.split(' - ');\n        const [hour, minute] = startTime.split(':').map(Number);\n        const slotMinutes = hour * 60 + minute;\n        const isPast = slotMinutes <= nowMinutes;\n        // console.log(`‚è∞ Slot ${slot} (${slotMinutes} min) - Past: ${isPast}`);\n        return !isPast;\n    });\n    // console.log('‚úÖ Past slots filtered:', filtered);\n    return filtered;\n}\n/**\n * Remove already booked slots (check for time overlap)\n */ function filterBookedSlots(slots, bookedSlots) {\n    // console.log('üîç Filtering booked slots. Available slots:', slots);\n    // console.log('üìÖ Booked slots:', bookedSlots);\n    const filtered = slots.filter((slot)=>{\n        const [slotStart, slotEnd] = slot.split(' - ');\n        const isBooked = bookedSlots.some((bookedTime)=>{\n            // Check if the booked time overlaps with this slot\n            // A booked time at 19:00 should block slots that start at 19:00 or later\n            // but also slots that end at 19:00 or later (like 18:15-19:00)\n            // Convert times to minutes for easier comparison\n            const slotStartMinutes = timeToMinutes(slotStart);\n            const slotEndMinutes = timeToMinutes(slotEnd);\n            const bookedMinutes = timeToMinutes(bookedTime);\n            // Check for overlap: slot overlaps if it starts before booked time ends\n            // and ends after booked time starts\n            // Since we don't know the duration of the booked slot, we assume it's 45 minutes\n            const bookedEndMinutes = bookedMinutes + 45; // Assume 45 min duration\n            const hasOverlap = slotStartMinutes < bookedEndMinutes && slotEndMinutes > bookedMinutes;\n            // console.log(`‚è∞ Slot ${slot} (${slotStartMinutes}-${slotEndMinutes} min) vs Booked ${bookedTime} (${bookedMinutes}-${bookedEndMinutes} min) - Overlap: ${hasOverlap}`);\n            return hasOverlap;\n        });\n        // console.log(`‚è∞ Slot ${slot} - Booked: ${isBooked}`);\n        return !isBooked;\n    });\n    // console.log('‚úÖ Filtered slots:', filtered);\n    return filtered;\n}\n/**\n * Convert time string (HH:MM) to minutes since midnight\n */ function timeToMinutes(time) {\n    const [hours, minutes] = time.split(':').map(Number);\n    return hours * 60 + minutes;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZ0JBOztDQUVDLEdBQ00sU0FBU0EsZ0NBQ2RDLGNBQWdDLEVBQ2hDQyxjQUE4QixFQUM5QkMsT0FBZTtJQUVmLE1BQU1DLFdBQVdILGVBQWVJLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUgsT0FBTyxLQUFLQTtJQUV4RCxJQUFJLENBQUNDLFlBQVksQ0FBQ0EsU0FBU0csUUFBUSxJQUFJSCxTQUFTSSxhQUFhLENBQUNDLE1BQU0sS0FBSyxHQUFHO1FBQzFFLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUMsUUFBa0IsRUFBRTtJQUMxQixNQUFNQyxrQkFBa0JULGVBQWVVLHNCQUFzQjtJQUU3RCxLQUFLLE1BQU1DLFlBQVlULFNBQVNJLGFBQWEsQ0FBRTtRQUM3QyxNQUFNLENBQUNNLFVBQVVDLFdBQVcsR0FBR0YsU0FBU0csUUFBUSxDQUFDQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUNoRSxNQUFNLENBQUNDLFdBQVdDLFlBQVksR0FBR1IsU0FBU1MsU0FBUyxDQUFDTCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztRQUVuRSxNQUFNSSxjQUFjVCxXQUFXLEtBQUtDO1FBQ3BDLE1BQU1TLGVBQWVKLFlBQVksS0FBS0M7UUFFdEMsc0NBQXNDO1FBQ3RDLElBQUlJLGlCQUFpQkY7UUFFckIsTUFBT0UsaUJBQWlCZCxrQkFBa0JhLGFBQWM7WUFDdEQsTUFBTUUsWUFBWUMsS0FBS0MsS0FBSyxDQUFDSCxpQkFBaUI7WUFDOUMsTUFBTUksY0FBY0osaUJBQWlCO1lBQ3JDLE1BQU1LLGFBQWFMLGlCQUFpQmQ7WUFDcEMsTUFBTW9CLFVBQVVKLEtBQUtDLEtBQUssQ0FBQ0UsYUFBYTtZQUN4QyxNQUFNRSxZQUFZRixhQUFhO1lBRS9CLE1BQU1HLFlBQVksR0FBNENKLE9BQXpDSCxVQUFVUSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxH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QU9QO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVNsQixjQUFjVCxJQUFZO0lBQ2pDLE1BQU0sQ0FBQ3NDLE9BQU9DLFFBQVEsR0FBR3ZDLEtBQUtoRCxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDQztJQUM3QyxPQUFPb0YsUUFBUSxLQUFLQztBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2tvbnN0YW50aW5vc2xlcGlkYXMvRGVza3RvcC9hdmdvdXN0ZS9hY3VwdW5jdHVyZS1ib29raW5nL3NyYy9saWIvc2xvdEdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgVGltZUludGVydmFsIHtcbiAgaWQ6IHN0cmluZztcbiAgb3BlblRpbWU6IHN0cmluZztcbiAgY2xvc2VUaW1lOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBPcGVyYXRpbmdIb3VycyB7XG4gIHdlZWtkYXk6IG51bWJlcjtcbiAgaXNBY3RpdmU6IGJvb2xlYW47XG4gIHRpbWVJbnRlcnZhbHM6IFRpbWVJbnRlcnZhbFtdO1xufVxuXG5pbnRlcmZhY2UgR2xvYmFsU2V0dGluZ3Mge1xuICBib29raW5nRHVyYXRpb25NaW51dGVzOiBudW1iZXI7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdGltZSBzbG90cyBiYXNlZCBvbiBvcGVyYXRpbmcgaG91cnMgYW5kIGJvb2tpbmcgZHVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2xvdHNGcm9tT3BlcmF0aW5nSG91cnMoXG4gIG9wZXJhdGluZ0hvdXJzOiBPcGVyYXRpbmdIb3Vyc1tdLFxuICBnbG9iYWxTZXR0aW5nczogR2xvYmFsU2V0dGluZ3MsXG4gIHdlZWtkYXk6IG51bWJlclxuKTogc3RyaW5nW10ge1xuICBjb25zdCBkYXlIb3VycyA9IG9wZXJhdGluZ0hvdXJzLmZpbmQoaCA9PiBoLndlZWtkYXkgPT09IHdlZWtkYXkpO1xuICBcbiAgaWYgKCFkYXlIb3VycyB8fCAhZGF5SG91cnMuaXNBY3RpdmUgfHwgZGF5SG91cnMudGltZUludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBzbG90czogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gZ2xvYmFsU2V0dGluZ3MuYm9va2luZ0R1cmF0aW9uTWludXRlcztcblxuICBmb3IgKGNvbnN0IGludGVydmFsIG9mIGRheUhvdXJzLnRpbWVJbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbb3BlbkhvdXIsIG9wZW5NaW51dGVdID0gaW50ZXJ2YWwub3BlblRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBjb25zdCBbY2xvc2VIb3VyLCBjbG9zZU1pbnV0ZV0gPSBpbnRlcnZhbC5jbG9zZVRpbWUuc3BsaXQoJzonKS5tYXAoTnVtYmVyKTtcbiAgICBcbiAgICBjb25zdCBvcGVuTWludXRlcyA9IG9wZW5Ib3VyICogNjAgKyBvcGVuTWludXRlO1xuICAgIGNvbnN0IGNsb3NlTWludXRlcyA9IGNsb3NlSG91ciAqIDYwICsgY2xvc2VNaW51dGU7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgc2xvdHMgd2l0aGluIHRoaXMgaW50ZXJ2YWxcbiAgICBsZXQgY3VycmVudE1pbnV0ZXMgPSBvcGVuTWludXRlcztcbiAgICBcbiAgICB3aGlsZSAoY3VycmVudE1pbnV0ZXMgKyBkdXJhdGlvbk1pbnV0ZXMgPCBjbG9zZU1pbnV0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0SG91ciA9IE1hdGguZmxvb3IoY3VycmVudE1pbnV0ZXMgLyA2MCk7XG4gICAgICBjb25zdCBzdGFydE1pbnV0ZSA9IGN1cnJlbnRNaW51dGVzICUgNjA7XG4gICAgICBjb25zdCBlbmRNaW51dGVzID0gY3VycmVudE1pbnV0ZXMgKyBkdXJhdGlvbk1pbnV0ZXM7XG4gICAgICBjb25zdCBlbmRIb3VyID0gTWF0aC5mbG9vcihlbmRNaW51dGVzIC8gNjApO1xuICAgICAgY29uc3QgZW5kTWludXRlID0gZW5kTWludXRlcyAlIDYwO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBgJHtzdGFydEhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke3N0YXJ0TWludXRlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICAgICAgY29uc3QgZW5kVGltZSA9IGAke2VuZEhvdXIudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2VuZE1pbnV0ZS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbiAgICAgIFxuICAgICAgc2xvdHMucHVzaChgJHtzdGFydFRpbWV9IC0gJHtlbmRUaW1lfWApO1xuICAgICAgXG4gICAgICBjdXJyZW50TWludXRlcyArPSBkdXJhdGlvbk1pbnV0ZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNsb3RzLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSkpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHNsb3RzIGZvciBhIHNwZWNpZmljIGRhdGUgdXNpbmcgb3BlcmF0aW5nIGhvdXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNsb3RzRm9yRGF0ZShcbiAgZGF0ZTogc3RyaW5nLFxuICBzZXJ2aWNlPzogc3RyaW5nXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIHRyeSB7XG4gICAgLy8gY29uc29sZS5sb2coJ/CflI0gR2VuZXJhdGluZyBzbG90cyBmb3IgZGF0ZTonLCBkYXRlLCAnc2VydmljZTonLCBzZXJ2aWNlKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IG9wZXJhdGluZyBob3VycyBhbmQgZ2xvYmFsIHNldHRpbmdzXG4gICAgY29uc3QgW2hvdXJzUmVzLCBzZXR0aW5nc1Jlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBmZXRjaCgnL2FwaS9vcGVyYXRpbmctaG91cnMnKS5jYXRjaCgoKSA9PiAoeyBqc29uOiAoKSA9PiBbXSB9KSksXG4gICAgICBmZXRjaCgnL2FwaS9nbG9iYWwtc2V0dGluZ3MnKS5jYXRjaCgoKSA9PiAoeyBqc29uOiAoKSA9PiBudWxsIH0pKVxuICAgIF0pO1xuICAgIFxuICAgIGNvbnN0IG9wZXJhdGluZ0hvdXJzOiBPcGVyYXRpbmdIb3Vyc1tdID0gYXdhaXQgaG91cnNSZXMuanNvbigpO1xuICAgIGNvbnN0IGdsb2JhbFNldHRpbmdzOiBHbG9iYWxTZXR0aW5ncyA9IGF3YWl0IHNldHRpbmdzUmVzLmpzb24oKTtcbiAgICBcbiAgICAvLyBjb25zb2xlLmxvZygn8J+TiiBPcGVyYXRpbmcgaG91cnM6Jywgb3BlcmF0aW5nSG91cnMpO1xuICAgIC8vIGNvbnNvbGUubG9nKCfimpnvuI8gR2xvYmFsIHNldHRpbmdzOicsIGdsb2JhbFNldHRpbmdzKTtcbiAgICBcbiAgICAvLyBJZiB3ZSBoYXZlIG9wZXJhdGluZyBob3VycyBjb25maWd1cmVkLCB1c2UgdGhlIG5ldyBzeXN0ZW1cbiAgICBpZiAob3BlcmF0aW5nSG91cnMubGVuZ3RoID4gMCAmJiBnbG9iYWxTZXR0aW5ncyAmJiBvcGVyYXRpbmdIb3Vycy5zb21lKGggPT4gaC5pc0FjdGl2ZSAmJiBoLnRpbWVJbnRlcnZhbHMubGVuZ3RoID4gMCkpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCfinIUgVXNpbmcgbmV3IG9wZXJhdGluZyBob3VycyBzeXN0ZW0nKTtcbiAgICAgIGNvbnN0IHdlZWtkYXkgPSBuZXcgRGF0ZShkYXRlKS5nZXREYXkoKTtcbiAgICAgIGNvbnN0IGJhc2VTbG90cyA9IGdlbmVyYXRlU2xvdHNGcm9tT3BlcmF0aW5nSG91cnMob3BlcmF0aW5nSG91cnMsIGdsb2JhbFNldHRpbmdzLCB3ZWVrZGF5KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCfwn46vIEdlbmVyYXRlZCBiYXNlIHNsb3RzOicsIGJhc2VTbG90cyk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBkYXRlLXNwZWNpZmljIG92ZXJyaWRlc1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ/CflI0gQ2hlY2tpbmcgZm9yIGRhdGUgb3ZlcnJpZGVzIGZvciBkYXRlOicsIGRhdGUpO1xuICAgICAgICBjb25zdCBvdmVycmlkZXNSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRlLW92ZXJyaWRlcz9kYXRlPSR7ZGF0ZX1gKTtcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gYXdhaXQgb3ZlcnJpZGVzUmVzLmpzb24oKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ/Cfk4sgRGF0ZSBvdmVycmlkZXMgZm91bmQ6Jywgb3ZlcnJpZGVzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG92ZXJyaWRlcykgJiYgb3ZlcnJpZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGVPdmVycmlkZXMgPSBvdmVycmlkZXNcbiAgICAgICAgICAgIC5maWx0ZXIoKG86IHsgYXZhaWxhYmxlOiBib29sZWFuOyBzZXJ2aWNlPzogc3RyaW5nIH0pID0+IFxuICAgICAgICAgICAgICBvLmF2YWlsYWJsZSAmJiAoIXNlcnZpY2UgfHwgIW8uc2VydmljZSB8fCBvLnNlcnZpY2UgPT09IHNlcnZpY2UpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKChvOiB7IHRpbWU6IHN0cmluZyB9KSA9PiBvLnRpbWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCfinIUgQXZhaWxhYmxlIG92ZXJyaWRlczonLCBhdmFpbGFibGVPdmVycmlkZXMpO1xuICAgICAgICAgIGlmIChhdmFpbGFibGVPdmVycmlkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZU92ZXJyaWRlcy5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gXG4gICAgICAgICAgICAgIGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCfimqDvuI8gTm8gYXZhaWxhYmxlIG92ZXJyaWRlcyBmb3VuZCwgdXNpbmcgYmFzZSBzbG90cyBpbnN0ZWFkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCfwn5OFIE5vIGRhdGUgb3ZlcnJpZGVzIGZvdW5kLCB1c2luZyBiYXNlIHNsb3RzJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIGRhdGUgb3ZlcnJpZGVzOicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgZm9yIGJsb2NrZWQgaW50ZXJ2YWxzXG4gICAgICB0cnkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+UjSBDaGVja2luZyBmb3IgYmxvY2tlZCBpbnRlcnZhbHMgZm9yIGRhdGU6JywgZGF0ZSk7XG4gICAgICAgIGNvbnN0IGJsb2NrZWRSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9ibG9ja2VkLWludGVydmFscz9kYXRlPSR7ZGF0ZX1gKTtcbiAgICAgICAgY29uc3QgYmxvY2tlZEludGVydmFscyA9IGF3YWl0IGJsb2NrZWRSZXMuanNvbigpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygn8J+aqyBCbG9ja2VkIGludGVydmFscyBmb3VuZDonLCBibG9ja2VkSW50ZXJ2YWxzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2NrZWRJbnRlcnZhbHMpICYmIGJsb2NrZWRJbnRlcnZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIEZpbHRlciBvdXQgc2xvdHMgdGhhdCBvdmVybGFwIHdpdGggYmxvY2tlZCBpbnRlcnZhbHNcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZFNsb3RzID0gYmFzZVNsb3RzLmZpbHRlcihzbG90ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzbG90U3RhcnQsIHNsb3RFbmRdID0gc2xvdC5zcGxpdCgnIC0gJyk7XG4gICAgICAgICAgICBjb25zdCBzbG90U3RhcnRNaW51dGVzID0gdGltZVRvTWludXRlcyhzbG90U3RhcnQpO1xuICAgICAgICAgICAgY29uc3Qgc2xvdEVuZE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKHNsb3RFbmQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBoYXNPdmVybGFwID0gYmxvY2tlZEludGVydmFscy5zb21lKChpbnRlcnZhbDogYW55KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGludGVydmFsU3RhcnRNaW51dGVzID0gdGltZVRvTWludXRlcyhpbnRlcnZhbC5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICBjb25zdCBpbnRlcnZhbEVuZE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKGludGVydmFsLmVuZFRpbWUpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcHMgPSBzbG90U3RhcnRNaW51dGVzIDwgaW50ZXJ2YWxFbmRNaW51dGVzICYmIHNsb3RFbmRNaW51dGVzID4gaW50ZXJ2YWxTdGFydE1pbnV0ZXM7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAob3ZlcmxhcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhg8J+aqyBTbG90ICR7c2xvdH0gb3ZlcmxhcHMgd2l0aCBibG9ja2VkIGludGVydmFsICR7aW50ZXJ2YWwuc3RhcnRUaW1lfS0ke2ludGVydmFsLmVuZFRpbWV9ICgke2ludGVydmFsLnJlYXNvbiB8fCAnTm8gcmVhc29uJ30pYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiBvdmVybGFwcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gIWhhc092ZXJsYXA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ+KchSBTbG90cyBhZnRlciBibG9ja2VkIGludGVydmFscyBmaWx0ZXI6JywgZmlsdGVyZWRTbG90cyk7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkU2xvdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ/Cfk4UgTm8gYmxvY2tlZCBpbnRlcnZhbHMgZm91bmQsIHVzaW5nIGJhc2Ugc2xvdHMnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggYmxvY2tlZCBpbnRlcnZhbHM6JywgZXJyb3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBjb25zb2xlLmxvZygn8J+OryBSZXR1cm5pbmcgYmFzZVNsb3RzIGZyb20gbmV3IHN5c3RlbTonLCBiYXNlU2xvdHMpO1xuICAgICAgcmV0dXJuIGJhc2VTbG90cztcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gb2xkIHN5c3RlbSAtIHVzZSBnbG9iYWwgdGltZXNsb3RzXG4gICAgLy8gY29uc29sZS5sb2coJ/CflIQgRmFsbGluZyBiYWNrIHRvIG9sZCBnbG9iYWwgdGltZXNsb3RzIHN5c3RlbScpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnbG9iYWxTbG90c1JlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2dsb2JhbC10aW1lc2xvdHMnKTtcbiAgICAgIGNvbnN0IGdsb2JhbFNsb3RzID0gYXdhaXQgZ2xvYmFsU2xvdHNSZXMuanNvbigpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ/Cfk4UgR2xvYmFsIHNsb3RzIGZyb20gb2xkIHN5c3RlbTonLCBnbG9iYWxTbG90cyk7XG4gICAgICBcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdsb2JhbFNsb3RzKSAmJiBnbG9iYWxTbG90cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdlZWtkYXkgPSBuZXcgRGF0ZShkYXRlKS5nZXREYXkoKTtcbiAgICAgICAgY29uc3Qgc2xvdHMgPSBnbG9iYWxTbG90c1xuICAgICAgICAgIC5maWx0ZXIoKHM6IHsgd2Vla2RheTogbnVtYmVyIH0pID0+IE51bWJlcihzLndlZWtkYXkpID09PSBOdW1iZXIod2Vla2RheSkpXG4gICAgICAgICAgLm1hcCgoczogeyB0aW1lOiBzdHJpbmcgfSkgPT4gcy50aW1lKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciBkYXRlLXNwZWNpZmljIG92ZXJyaWRlc1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlc1JlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGUtb3ZlcnJpZGVzP2RhdGU9JHtkYXRlfWApO1xuICAgICAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IGF3YWl0IG92ZXJyaWRlc1Jlcy5qc29uKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3ZlcnJpZGVzKSAmJiBvdmVycmlkZXMuc29tZSgobzogeyBhdmFpbGFibGU6IGJvb2xlYW4gfSkgPT4gby5hdmFpbGFibGUpKSB7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSBvdmVycmlkZXNcbiAgICAgICAgICAgICAgLmZpbHRlcigobzogeyBhdmFpbGFibGU6IGJvb2xlYW4gfSkgPT4gby5hdmFpbGFibGUpXG4gICAgICAgICAgICAgIC5tYXAoKG86IHsgdGltZTogc3RyaW5nIH0pID0+IG8udGltZSk7XG4gICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYiwgJ2VuJywgeyBudW1lcmljOiB0cnVlIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggZGF0ZSBvdmVycmlkZXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2xvdHMuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiLCAnZW4nLCB7IG51bWVyaWM6IHRydWUgfSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmZXRjaCBnbG9iYWwgdGltZXNsb3RzOicsIGVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluYWwgZmFsbGJhY2sgLSByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICAvLyBjb25zb2xlLmxvZygn4p2MIE5vIHNsb3RzIGZvdW5kIGZvciBkYXRlOicsIGRhdGUpO1xuICAgIHJldHVybiBbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZ2VuZXJhdGluZyBzbG90cyBmb3IgZGF0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRmlsdGVyIG91dCBwYXN0IHNsb3RzIGlmIHRoZSBkYXRlIGlzIHRvZGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXN0U2xvdHMoc2xvdHM6IHN0cmluZ1tdLCBkYXRlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3Qgc2VsZWN0ZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIFxuICAvLyBjb25zb2xlLmxvZygn8J+VkCBGaWx0ZXJpbmcgcGFzdCBzbG90cy4gRGF0ZTonLCBkYXRlLCAnVG9kYXk6JywgdG9kYXkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKTtcbiAgXG4gIC8vIElmIG5vdCB0b2RheSwgcmV0dXJuIGFsbCBzbG90c1xuICBpZiAoXG4gICAgdG9kYXkuZ2V0RnVsbFllYXIoKSAhPT0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCkgfHxcbiAgICB0b2RheS5nZXRNb250aCgpICE9PSBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSB8fFxuICAgIHRvZGF5LmdldERhdGUoKSAhPT0gc2VsZWN0ZWREYXRlLmdldERhdGUoKVxuICApIHtcbiAgICAvLyBjb25zb2xlLmxvZygn8J+ThSBOb3QgdG9kYXksIHJldHVybmluZyBhbGwgc2xvdHM6Jywgc2xvdHMpO1xuICAgIHJldHVybiBzbG90cztcbiAgfVxuICBcbiAgLy8gRmlsdGVyIG91dCBwYXN0IHNsb3RzXG4gIGNvbnN0IG5vd01pbnV0ZXMgPSB0b2RheS5nZXRIb3VycygpICogNjAgKyB0b2RheS5nZXRNaW51dGVzKCk7XG4gIC8vIGNvbnNvbGUubG9nKCfij7AgQ3VycmVudCB0aW1lIGluIG1pbnV0ZXM6Jywgbm93TWludXRlcyk7XG4gIFxuICBjb25zdCBmaWx0ZXJlZCA9IHNsb3RzLmZpbHRlcihzbG90ID0+IHtcbiAgICBjb25zdCBbc3RhcnRUaW1lXSA9IHNsb3Quc3BsaXQoJyAtICcpO1xuICAgIGNvbnN0IFtob3VyLCBtaW51dGVdID0gc3RhcnRUaW1lLnNwbGl0KCc6JykubWFwKE51bWJlcik7XG4gICAgY29uc3Qgc2xvdE1pbnV0ZXMgPSBob3VyICogNjAgKyBtaW51dGU7XG4gICAgY29uc3QgaXNQYXN0ID0gc2xvdE1pbnV0ZXMgPD0gbm93TWludXRlcztcbiAgICAvLyBjb25zb2xlLmxvZyhg4o+wIFNsb3QgJHtzbG90fSAoJHtzbG90TWludXRlc30gbWluKSAtIFBhc3Q6ICR7aXNQYXN0fWApO1xuICAgIHJldHVybiAhaXNQYXN0O1xuICB9KTtcbiAgXG4gIC8vIGNvbnNvbGUubG9nKCfinIUgUGFzdCBzbG90cyBmaWx0ZXJlZDonLCBmaWx0ZXJlZCk7XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxyZWFkeSBib29rZWQgc2xvdHMgKGNoZWNrIGZvciB0aW1lIG92ZXJsYXApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJCb29rZWRTbG90cyhzbG90czogc3RyaW5nW10sIGJvb2tlZFNsb3RzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcbiAgLy8gY29uc29sZS5sb2coJ/CflI0gRmlsdGVyaW5nIGJvb2tlZCBzbG90cy4gQXZhaWxhYmxlIHNsb3RzOicsIHNsb3RzKTtcbiAgLy8gY29uc29sZS5sb2coJ/Cfk4UgQm9va2VkIHNsb3RzOicsIGJvb2tlZFNsb3RzKTtcbiAgXG4gIGNvbnN0IGZpbHRlcmVkID0gc2xvdHMuZmlsdGVyKHNsb3QgPT4ge1xuICAgIGNvbnN0IFtzbG90U3RhcnQsIHNsb3RFbmRdID0gc2xvdC5zcGxpdCgnIC0gJyk7XG4gICAgY29uc3QgaXNCb29rZWQgPSBib29rZWRTbG90cy5zb21lKGJvb2tlZFRpbWUgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJvb2tlZCB0aW1lIG92ZXJsYXBzIHdpdGggdGhpcyBzbG90XG4gICAgICAvLyBBIGJvb2tlZCB0aW1lIGF0IDE5OjAwIHNob3VsZCBibG9jayBzbG90cyB0aGF0IHN0YXJ0IGF0IDE5OjAwIG9yIGxhdGVyXG4gICAgICAvLyBidXQgYWxzbyBzbG90cyB0aGF0IGVuZCBhdCAxOTowMCBvciBsYXRlciAobGlrZSAxODoxNS0xOTowMClcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCB0aW1lcyB0byBtaW51dGVzIGZvciBlYXNpZXIgY29tcGFyaXNvblxuICAgICAgY29uc3Qgc2xvdFN0YXJ0TWludXRlcyA9IHRpbWVUb01pbnV0ZXMoc2xvdFN0YXJ0KTtcbiAgICAgIGNvbnN0IHNsb3RFbmRNaW51dGVzID0gdGltZVRvTWludXRlcyhzbG90RW5kKTtcbiAgICAgIGNvbnN0IGJvb2tlZE1pbnV0ZXMgPSB0aW1lVG9NaW51dGVzKGJvb2tlZFRpbWUpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3Igb3ZlcmxhcDogc2xvdCBvdmVybGFwcyBpZiBpdCBzdGFydHMgYmVmb3JlIGJvb2tlZCB0aW1lIGVuZHNcbiAgICAgIC8vIGFuZCBlbmRzIGFmdGVyIGJvb2tlZCB0aW1lIHN0YXJ0c1xuICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgZHVyYXRpb24gb2YgdGhlIGJvb2tlZCBzbG90LCB3ZSBhc3N1bWUgaXQncyA0NSBtaW51dGVzXG4gICAgICBjb25zdCBib29rZWRFbmRNaW51dGVzID0gYm9va2VkTWludXRlcyArIDQ1OyAvLyBBc3N1bWUgNDUgbWluIGR1cmF0aW9uXG4gICAgICBcbiAgICAgIGNvbnN0IGhhc092ZXJsYXAgPSBzbG90U3RhcnRNaW51dGVzIDwgYm9va2VkRW5kTWludXRlcyAmJiBzbG90RW5kTWludXRlcyA+IGJvb2tlZE1pbnV0ZXM7XG4gICAgICBcbiAgICAgIC8vIGNvbnNvbGUubG9nKGDij7AgU2xvdCAke3Nsb3R9ICgke3Nsb3RTdGFydE1pbnV0ZXN9LSR7c2xvdEVuZE1pbnV0ZXN9IG1pbikgdnMgQm9va2VkICR7Ym9va2VkVGltZX0gKCR7Ym9va2VkTWludXRlc30tJHtib29rZWRFbmRNaW51dGVzfSBtaW4pIC0gT3ZlcmxhcDogJHtoYXNPdmVybGFwfWApO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzT3ZlcmxhcDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBjb25zb2xlLmxvZyhg4o+wIFNsb3QgJHtzbG90fSAtIEJvb2tlZDogJHtpc0Jvb2tlZH1gKTtcbiAgICByZXR1cm4gIWlzQm9va2VkO1xuICB9KTtcbiAgXG4gIC8vIGNvbnNvbGUubG9nKCfinIUgRmlsdGVyZWQgc2xvdHM6JywgZmlsdGVyZWQpO1xuICByZXR1cm4gZmlsdGVyZWQ7XG59XG5cbi8qKlxuICogQ29udmVydCB0aW1lIHN0cmluZyAoSEg6TU0pIHRvIG1pbnV0ZXMgc2luY2UgbWlkbmlnaHRcbiAqL1xuZnVuY3Rpb24gdGltZVRvTWludXRlcyh0aW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBbaG91cnMsIG1pbnV0ZXNdID0gdGltZS5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xuICByZXR1cm4gaG91cnMgKiA2MCArIG1pbnV0ZXM7XG59XG4iXSwibmFtZXMiOlsiZ2VuZXJhdGVTbG90c0Zyb21PcGVyYXRpbmdIb3VycyIsIm9wZXJhdGluZ0hvdXJzIiwiZ2xvYmFsU2V0dGluZ3MiLCJ3ZWVrZGF5IiwiZGF5SG91cnMiLCJmaW5kIiwiaCIsImlzQWN0aXZlIiwidGltZUludGVydmFscyIsImxlbmd0aCIsInNsb3RzIiwiZHVyYXRpb25NaW51dGVzIiwiYm9va2luZ0R1cmF0aW9uTWludXRlcyIsImludGVydmFsIiwib3BlbkhvdXIiLCJvcGVuTWludXRlIiwib3BlblRpbWUiLCJzcGxpdCIsIm1hcCIsIk51bWJlciIsImNsb3NlSG91ciIsImNsb3NlTWludXRlIiwiY2xvc2VUaW1lIiwib3Blbk1pbnV0ZXMiLCJjbG9zZU1pbnV0ZXMiLCJjdXJyZW50TWludXRlcyIsInN0YXJ0SG91ciIsIk1hdGgiLCJmbG9vciIsInN0YXJ0TWludXRlIiwiZW5kTWludXRlcyIsImVuZEhvdXIiLCJlbmRNaW51dGUiLCJzdGFydFRpbWUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZW5kVGltZSIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibnVtZXJpYyIsImdlbmVyYXRlU2xvdHNGb3JEYXRlIiwiZGF0ZSIsInNlcnZpY2UiLCJob3Vyc1JlcyIsInNldHRpbmdzUmVzIiwiUHJvbWlzZSIsImFsbCIsImZldGNoIiwiY2F0Y2giLCJqc29uIiwic29tZSIsIkRhdGUiLCJnZXREYXkiLCJiYXNlU2xvdHMiLCJvdmVycmlkZXNSZXMiLCJvdmVycmlkZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhdmFpbGFibGVPdmVycmlkZXMiLCJmaWx0ZXIiLCJvIiwiYXZhaWxhYmxlIiwidGltZSIsImVycm9yIiwiYmxvY2tlZFJlcyIsImJsb2NrZWRJbnRlcnZhbHMiLCJmaWx0ZXJlZFNsb3RzIiwic2xvdCIsInNsb3RTdGFydCIsInNsb3RFbmQiLCJzbG90U3RhcnRNaW51dGVzIiwidGltZVRvTWludXRlcyIsInNsb3RFbmRNaW51dGVzIiwiaGFzT3ZlcmxhcCIsImludGVydmFsU3RhcnRNaW51dGVzIiwiaW50ZXJ2YWxFbmRNaW51dGVzIiwib3ZlcmxhcHMiLCJnbG9iYWxTbG90c1JlcyIsImdsb2JhbFNsb3RzIiwicyIsImZpbHRlclBhc3RTbG90cyIsInRvZGF5Iiwic2VsZWN0ZWREYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJub3dNaW51dGVzIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZmlsdGVyZWQiLCJob3VyIiwibWludXRlIiwic2xvdE1pbnV0ZXMiLCJpc1Bhc3QiLCJmaWx0ZXJCb29rZWRTbG90cyIsImJvb2tlZFNsb3RzIiwiaXNCb29rZWQiLCJib29rZWRUaW1lIiwiYm9va2VkTWludXRlcyIsImJvb2tlZEVuZE1pbnV0ZXMiLCJob3VycyIsIm1pbnV0ZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/slotGenerator.ts\n"));

/***/ })

});